<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dungeon Arena - Team Combat</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0d0d0d;
  background-image: radial-gradient(circle at 50% 50%, #1a1510 0%, #0d0d0d 70%);
  color: #d4c5a0;
  font-family: 'Segoe UI', system-ui, sans-serif;
  height: 100vh;
  display: flex; justify-content: center; align-items: center;
}
#game {
  width: 980px; height: 700px;
  display: flex; flex-direction: column;
  border: 2px solid #3a2a1a; border-radius: 8px; overflow: hidden;
  background: #1a1410;
}
#score-bar {
  text-align: center; font-size: 12px; color: #7a6a4a;
  padding: 4px; background: #0a0a08;
  border-bottom: 1px solid #2a2010;
}
#battle-scene {
  flex: 1; position: relative; min-height: 280px;
  background: linear-gradient(180deg, #1a1018 0%, #1a1520 25%, #181818 50%, #2a2218 75%, #1a1a10 100%);
  overflow: hidden; display: flex;
}
#battle-scene::after {
  content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 40%;
  background:
    repeating-linear-gradient(90deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 1px, transparent 1px, transparent 60px),
    repeating-linear-gradient(0deg, rgba(255,255,255,0.015) 0px, rgba(255,255,255,0.015) 1px, transparent 1px, transparent 40px);
  pointer-events: none;
}
#battle-scene::before {
  content: ''; position: absolute; inset: 0;
  background: radial-gradient(ellipse at 20% 30%, rgba(255,150,50,0.06) 0%, transparent 50%),
              radial-gradient(ellipse at 80% 40%, rgba(255,100,50,0.04) 0%, transparent 50%);
  animation: flicker 3s ease-in-out infinite alternate;
  pointer-events: none;
}
@keyframes flicker { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.8; } }

/* Team Rosters */
.team-roster {
  width: 105px; display: flex; flex-direction: column; gap: 4px;
  padding: 8px 6px; z-index: 15; flex-shrink: 0;
}
.team-roster.player-roster { border-right: 1px solid #2a2010; background: rgba(10,10,8,0.5); }
.team-roster.opp-roster { border-left: 1px solid #2a2010; background: rgba(10,10,8,0.5); }
.roster-entry {
  background: #1a1510; border: 1px solid #3a2a1a; border-radius: 4px;
  padding: 4px 6px; font-size: 9px; cursor: default; transition: border-color 0.2s;
  position: relative;
}
.roster-entry.active { border-color: #8a6a3a; background: #2a2018; }
.roster-entry.fainted { opacity: 0.4; }
.roster-entry.switchable { cursor: pointer; }
.roster-entry.switchable:hover { border-color: #aa8a4a; background: #2a2518; }
.roster-name { font-weight: 700; font-size: 10px; color: #e8d8b0; }
.roster-class { color: #7a6a4a; font-size: 8px; }
.roster-hp-bar { height: 4px; background: #1a1208; border-radius: 2px; margin-top: 2px; overflow: hidden; }
.roster-hp-fill { height: 100%; background: #6a8a3a; border-radius: 2px; transition: width 0.4s; }
.roster-hp-fill.yellow { background: #aa8a2a; }
.roster-hp-fill.red { background: #aa3a2a; }

/* Battle Area */
#arena { flex: 1; position: relative; }
.monster-platform {
  position: absolute; width: 120px; height: 16px; border-radius: 50%;
  background: radial-gradient(ellipse, rgba(0,0,0,0.3) 0%, transparent 70%);
}
.opponent-area { position: absolute; top: 30px; right: 100px; z-index: 5; }
.opponent-area .monster-platform { bottom: -8px; left: 50%; transform: translateX(-50%); }
.player-area { position: absolute; bottom: 55px; left: 80px; }
.player-area .monster-platform { bottom: -8px; left: 50%; transform: translateX(-50%); width: 140px; }
.monster-sprite {
  width: 96px; height: 96px; image-rendering: pixelated;
  transition: transform 0.15s, opacity 0.3s, filter 0.15s;
}
.player-area .monster-sprite { width: 112px; height: 112px; }
.monster-sprite.hit { animation: shake 0.3s; filter: brightness(2) saturate(0); }
.monster-sprite.attacking { animation: lunge 0.3s; }
.monster-sprite.fainted { opacity: 0; transform: translateY(40px); transition: all 0.6s; }
.monster-sprite.entering { animation: slideIn 0.4s ease-out; }
@keyframes shake { 0%,100% { transform: translateX(0); } 25% { transform: translateX(-8px); } 50% { transform: translateX(8px); } 75% { transform: translateX(-4px); } }
@keyframes lunge { 0%,100% { transform: translateX(0); } 50% { transform: translateX(20px) translateY(-10px); } }
@keyframes slideIn { 0% { opacity: 0; transform: translateY(30px); } 100% { opacity: 1; transform: translateY(0); } }
.dmg-float {
  position: absolute; font-weight: 900; font-size: 22px;
  pointer-events: none; z-index: 50;
  text-shadow: 1px 1px 2px #000, -1px -1px 2px #000;
  animation: floatUp 1.5s ease-out forwards;
}
.dmg-float.crit { font-size: 28px; color: #ffcc00 !important; }
.dmg-float.heal { color: #6aaa5a !important; }
@keyframes floatUp { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-50px); } }

/* HP Boxes */
.hp-box {
  position: absolute; z-index: 10;
  background: linear-gradient(135deg, #1a1510 0%, #2a2018 100%);
  border: 2px solid #4a3a20; border-radius: 6px;
  padding: 8px 12px; min-width: 220px;
}
.hp-box.opponent { top: 15px; left: 15px; }
.hp-box.player { bottom: 30px; right: 15px; }
.hp-box .name { font-weight: 700; font-size: 14px; color: #e8d8b0; }
.hp-box .class-label { font-size: 11px; color: #8a7a5a; margin-left: 6px; }
.hp-box .level { font-size: 11px; color: #7a6a4a; float: right; }
.stat-row { display: flex; gap: 4px; margin-top: 3px; font-size: 9px; color: #6a5a3a; flex-wrap: wrap; }
.stat-row span { background: #1a1208; padding: 1px 4px; border-radius: 2px; }
.type-row { font-size: 9px; margin-top: 2px; }
.type-row .resist-tag { color: #5a8a5a; }
.type-row .vuln-tag { color: #aa6a3a; }
.hp-bar-container { background: #1a1208; border-radius: 3px; height: 8px; overflow: hidden; margin-top: 4px; border: 1px solid #3a2a1a; }
.hp-bar { height: 100%; border-radius: 3px; transition: width 0.5s ease, background 0.3s; background: #6a8a3a; }
.hp-bar.yellow { background: #aa8a2a; }
.hp-bar.red { background: #aa3a2a; }
.hp-text { font-size: 10px; text-align: right; margin-top: 2px; color: #6a5a3a; }
.status-badge { display: inline-block; font-size: 9px; padding: 1px 5px; border-radius: 3px; margin-left: 6px; font-weight: 700; }
.status-badge.poison { background: #2a4a1a; color: #6a4; }
.status-badge.stun { background: #4a4a1a; color: #aa8; }
.status-badge.slow { background: #1a2a4a; color: #68a; }
.status-badge.frozen { background: #1a3a5a; color: #8ad; }
.status-badge.blind { background: #4a4a2a; color: #cc8; }
.status-effect-tag.blind { background: #4a4a2a; color: #cc8; }

/* Status Effects Row */
.status-effects-row { display: flex; gap: 3px; margin-top: 3px; flex-wrap: wrap; }
.status-effect-tag { display: inline-flex; align-items: center; gap: 2px; font-size: 9px; padding: 1px 5px; border-radius: 3px; font-weight: 700; }
.status-effect-tag.poison { background: #2a4a1a; color: #6a4; }
.status-effect-tag.stun { background: #4a4a1a; color: #aa8; }
.status-effect-tag.slow { background: #1a2a4a; color: #68a; }
.status-effect-tag.frozen { background: #1a3a5a; color: #8ad; }
.roster-status { font-size: 8px; margin-top: 1px; }
.roster-status .status-effect-tag { font-size: 7px; padding: 0 3px; }

/* Death Selection Modal */
#death-select-modal {
  display: none; position: absolute; inset: 0; z-index: 100;
  background: rgba(0,0,0,0.7); justify-content: center; align-items: center;
}
#death-select-modal.show { display: flex; }
#death-select-modal .death-box {
  background: linear-gradient(135deg, #1a1510, #2a2018); border: 2px solid #5a4a2a;
  border-radius: 8px; padding: 16px; max-width: 420px; text-align: center;
}
#death-select-modal .death-box h3 { color: #cc5544; margin-bottom: 6px; font-size: 15px; }
#death-select-modal .death-box p { color: #9a8a6a; font-size: 11px; margin-bottom: 10px; }
#death-select-modal .char-btn {
  display: block; width: 100%; margin: 5px 0; padding: 10px;
  background: #2a2518; border: 2px solid #4a3a20; border-radius: 6px;
  color: #d4c5a0; font-size: 12px; cursor: pointer; text-align: left;
  transition: border-color 0.15s;
}
#death-select-modal .char-btn:hover { border-color: #aa8a4a; background: #3a3020; }
#death-select-modal .char-name { font-weight: 700; font-size: 13px; }
#death-select-modal .char-info { font-size: 10px; color: #9a8a6a; margin-top: 2px; }

/* Stance Modal */
#stance-modal {
  display: none; position: absolute; inset: 0; z-index: 100;
  background: rgba(0,0,0,0.7); justify-content: center; align-items: center;
}
#stance-modal.show { display: flex; }
#stance-modal .stance-box {
  background: linear-gradient(135deg, #1a1510, #2a2018); border: 2px solid #5a4a2a;
  border-radius: 8px; padding: 16px; max-width: 400px; text-align: center;
}
#stance-modal .stance-box h3 { color: #e8d8b0; margin-bottom: 10px; font-size: 15px; }
#stance-modal .stance-btn {
  display: block; width: 100%; margin: 6px 0; padding: 10px;
  background: #2a2518; border: 2px solid #4a3a20; border-radius: 6px;
  color: #d4c5a0; font-size: 12px; cursor: pointer; text-align: left;
  transition: border-color 0.15s;
}
#stance-modal .stance-btn:hover { border-color: #aa8a4a; background: #3a3020; }
#stance-modal .stance-btn .stance-name { font-weight: 700; font-size: 13px; color: #e8d8b0; }
#stance-modal .stance-btn .stance-desc { font-size: 10px; color: #9a8a6a; margin-top: 3px; }
.stance-indicator { font-size: 9px; color: #8ab; margin-left: 6px; font-style: italic; }

/* Stance Info Panels */
.stance-info-panel { display: none; }
.stance-inline { font-size: 9px; margin-top: 3px; padding: 2px 5px; background: #1a1208; border-radius: 3px; }
.stance-inline .stance-label { color: #8ab; font-weight: 700; }
.stance-inline .stance-name-text { color: #e8d8b0; font-weight: 600; }
.stance-inline .stance-desc-text { color: #9a8a6a; font-style: italic; }

/* Bottom Panel */
#bottom-panel { height: 240px; display: flex; background: #12100c; border-top: 2px solid #3a2a1a; }
#battle-log {
  flex: 1; padding: 10px 14px; overflow-y: auto;
  font-size: 12px; line-height: 1.6;
  border-right: 2px solid #2a2010;
  scroll-behavior: smooth; font-family: 'Georgia', serif;
}
#battle-log .log-line { margin-bottom: 2px; }
#battle-log .damage { color: #cc6644; }
#battle-log .heal { color: #6aaa5a; }
#battle-log .info { color: #8a9aaa; }
#battle-log .crit { color: #ddaa33; font-weight: 700; }
#battle-log .miss { color: #666; font-style: italic; }
#battle-log .resist { color: #777; }
#battle-log .vuln { color: #dd8833; }
#battle-log .status { color: #aa77cc; }
#battle-log .faint { color: #cc5544; font-weight: 700; }
#battle-log .win { color: #ddaa33; font-weight: 700; font-size: 14px; }
#battle-log .divider { color: #444; border-top: 1px solid #2a2010; padding-top: 4px; margin-top: 6px; }
#battle-log .roll { color: #6688aa; font-size: 11px; }
#battle-log .switch { color: #8ab; }

#controls { width: 370px; padding: 8px; display: flex; flex-direction: column; gap: 5px; }
#move-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; flex: 1; }
.move-btn {
  border: 2px solid #3a2a1a; border-radius: 6px;
  padding: 7px; cursor: pointer;
  font-size: 12px; font-weight: 600; color: #e8d8b0;
  text-align: left; display: flex; flex-direction: column; justify-content: center;
  transition: filter 0.15s, transform 0.1s;
  position: relative;
}
.move-btn:hover { filter: brightness(1.25); transform: scale(1.02); }
.move-btn:active { transform: scale(0.98); }
.move-btn:disabled { opacity: 0.35; cursor: not-allowed; transform: none; filter: none; }
.move-btn .move-name { font-size: 13px; }
.move-btn .move-info { font-size: 9px; opacity: 0.75; margin-top: 2px; }
.move-btn[data-dmg="physical"] { background: #4a3a2a; }
.move-btn[data-dmg="magical"] { background: #2a2a4a; }
.move-btn[data-dmg="soul"] { background: #3a1a3a; }
.move-btn[data-dmg="heal"] { background: #2a4a2a; }

#action-bar { display: flex; gap: 5px; align-items: center; }
#action-bar button {
  flex: 1; padding: 7px;
  border: 2px solid #3a2a1a; border-radius: 6px;
  background: #1a1510; color: #b0a080;
  font-size: 12px; font-weight: 600; cursor: pointer;
  transition: background 0.15s;
}
#action-bar button:hover { background: #2a2018; }
#action-bar button.active { background: #3a2a18; border-color: #8a6a3a; color: #e8d8b0; }
#speed-control {
  display: flex; align-items: center; gap: 4px;
  font-size: 10px; color: #7a6a4a; padding: 2px 0;
}
#speed-control input[type=range] { width: 60px; accent-color: #8a6a3a; }

/* Tooltip */
#tooltip {
  display: none; position: fixed; z-index: 1000;
  background: linear-gradient(135deg, #1a1510 0%, #222018 100%);
  border: 2px solid #5a4a2a; border-radius: 8px;
  padding: 10px 12px; width: 260px;
  font-size: 11px; color: #d4c5a0;
  box-shadow: 0 4px 16px rgba(0,0,0,0.6);
  pointer-events: none;
}
#tooltip .tt-name { font-size: 14px; font-weight: 700; color: #e8d8b0; margin-bottom: 4px; }
#tooltip .tt-type { font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 6px; }
#tooltip .tt-type.physical { background: #4a3a2a; color: #d4a870; }
#tooltip .tt-type.magical { background: #2a2a4a; color: #a0a0e0; }
#tooltip .tt-type.soul { background: #3a1a3a; color: #c080c0; }
#tooltip .tt-type.heal { background: #2a4a2a; color: #80c080; }
#tooltip .tt-stats { display: flex; flex-direction: column; gap: 3px; margin-bottom: 6px; }
#tooltip .tt-stat { display: flex; justify-content: space-between; }
#tooltip .tt-stat-label { color: #8a7a5a; }
#tooltip .tt-stat-val { color: #d4c5a0; font-weight: 600; }
#tooltip .tt-desc { font-style: italic; color: #9a8a6a; font-size: 10px; border-top: 1px solid #2a2010; padding-top: 6px; margin-top: 2px; }
#tooltip .tt-variance { font-size: 10px; font-weight: 600; margin-top: 4px; }
#tooltip .tt-variance.low { color: #6a8a5a; }
#tooltip .tt-variance.med { color: #aa8a3a; }
#tooltip .tt-variance.high { color: #cc6644; }
#tooltip .tt-variance.extreme { color: #cc4444; }
#tooltip .tt-effectiveness { font-size: 10px; font-weight: 700; margin-top: 4px; padding: 2px 0; }
#tooltip .tt-effectiveness.super { color: #dd8833; }
#tooltip .tt-effectiveness.resisted { color: #777; }
#tooltip .tt-range-bar { height: 6px; background: #1a1208; border-radius: 3px; margin-top: 4px; position: relative; overflow: visible; }
#tooltip .tt-range-fill { position: absolute; height: 100%; background: #4a6a3a; border-radius: 3px; }
#tooltip .tt-range-avg { position: absolute; width: 2px; height: 10px; top: -2px; background: #e8d8b0; }
#tooltip .tt-range-labels { display: flex; justify-content: space-between; font-size: 9px; color: #6a5a3a; margin-top: 2px; }
</style>
</head>
<body>
<div id="game">
  <div id="score-bar">Victories: <span id="p-wins">0</span> | Defeats: <span id="p-losses">0</span> | Encounter #<span id="battle-num">1</span> <span id="terrain-display"></span></div>
  <div id="battle-scene">
    <div class="team-roster player-roster" id="player-roster"></div>
    <div id="arena">
      <div class="hp-box opponent">
        <span class="name" id="opp-name">???</span>
        <span class="class-label" id="opp-class"></span>
        <span class="level" id="opp-level"></span>
        <div class="stat-row" id="opp-stats"></div>
        <div class="type-row" id="opp-types"></div>
        <div class="hp-bar-container"><div class="hp-bar" id="opp-hp-bar"></div></div>
        <div class="hp-text" id="opp-hp-text">???/???</div>
      </div>
      <div class="opponent-area">
        <canvas class="monster-sprite" id="opp-sprite" width="96" height="96"></canvas>
        <div class="monster-platform"></div>
      </div>
      <div class="player-area">
        <canvas class="monster-sprite" id="player-sprite" width="112" height="112"></canvas>
        <div class="monster-platform"></div>
      </div>
      <div class="stance-info-panel opp-stance" id="opp-stance-info"></div>
      <div class="stance-info-panel player-stance" id="player-stance-info"></div>
      <div class="hp-box player">
        <span class="name" id="player-name">???</span>
        <span class="class-label" id="player-class"></span>
        <span class="level" id="player-level"></span>
        <div class="stat-row" id="player-stats"></div>
        <div class="type-row" id="player-types"></div>
        <div class="hp-bar-container"><div class="hp-bar" id="player-hp-bar"></div></div>
        <div class="hp-text" id="player-hp-text">???/???</div>
      </div>
    </div>
    <div class="team-roster opp-roster" id="opp-roster"></div>
  </div>
  <div id="bottom-panel">
    <div id="battle-log"></div>
    <div id="controls">
      <div id="move-buttons"></div>
      <div id="action-bar">
        <button id="btn-fight">Fight</button>
        <button id="btn-auto">Auto Battle</button>
      </div>
      <div id="speed-control">
        <span>Speed:</span>
        <input type="range" id="speed-slider" min="50" max="1000" value="500" step="50">
        <span id="speed-label">500ms</span>
      </div>
    </div>
  </div>
</div>
<div id="tooltip"></div>
<div id="stance-modal"><div class="stance-box" id="stance-box"></div></div>
<div id="death-select-modal"><div class="death-box" id="death-box"></div></div>

<script>
// ============================================================
//  HELPERS
// ============================================================
function mod(score) { return Math.floor((score - 10) / 2); }
function d(n) { return Math.floor(Math.random() * n) + 1; }
function rollDice(count, sides) { let t = 0; for (let i = 0; i < count; i++) t += d(sides); return t; }
function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
function shadeColor(c, p) { const n=parseInt(c.replace('#',''),16); const r=Math.min(255,Math.max(0,(n>>16)+p)); const g=Math.min(255,Math.max(0,((n>>8)&0xFF)+p)); const b=Math.min(255,Math.max(0,(n&0xFF)+p)); return '#'+(0x1000000+r*0x10000+g*0x100+b).toString(16).slice(1); }
function hashStr(s) { let h=0; for(let i=0;i<s.length;i++){h=((h<<5)-h)+s.charCodeAt(i);h|=0;} return Math.abs(h); }
function mulberry32(a) { return function(){a|=0;a=a+0x6D2B79F5|0;let t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296;}; }
function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function shuffle(arr) { const a=[...arr]; for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} return a; }

// ============================================================
//  DAMAGE TYPES & EFFECTIVENESS
//  Cycle: Physical > Curse > Divine > Elemental > Magical > Physical
// ============================================================
const DMG_TYPES = ['physical','magical','soul'];
const TYPE_LABELS = { physical:'Physical', magical:'Magical', soul:'Soul', heal:'Heal' };
const TYPE_ICONS = { physical:'\u2694', magical:'\u2728', soul:'\uD83D\uDC80', heal:'\u2764' };

// ============================================================
//  ABILITIES - Higher expected damage = more dice sides, fewer dice = higher variance
// ============================================================
const ABILITIES = {
  // DAMAGE FORMAT: fixed + NdX. Fixed = 40-80% of expected damage. No bonus field.
  // Low variance (80% fixed): consistent, reliable moves
  // Medium variance (60% fixed): balanced risk/reward
  // High variance (40% fixed): swingy, feast-or-famine
  // PHYSICAL
  swordSlash:   { name:'Sword Slash',     dmgType:'physical', stat:'atk', fixed:9,  dice:[1,4],  acc:1,  uses:20, desc:'Reliable quick slashes. Very consistent damage output.' },
  shieldBash:   { name:'Shield Bash',     dmgType:'physical', stat:'atk', fixed:5,  dice:[1,6],  acc:0,  uses:14, desc:'Heavy shield strike. Lower damage but may stun the target.', effect:'stun' },
  execute:      { name:'Execute',         dmgType:'physical', stat:'atk', fixed:5,  dice:[2,6],  acc:-1, uses:5,  desc:'Devastating finishing blow. High risk, high reward.' },
  cleave:       { name:'Cleave',          dmgType:'physical', stat:'atk', fixed:4,  dice:[2,6],  acc:0,  uses:10, desc:'Wide sweeping slash. High variance — big hits or weak swings.' },
  quickStrike:  { name:'Quick Strike',    dmgType:'physical', stat:'spd', fixed:9,  dice:[1,4],  acc:2,  uses:22, desc:'Rapid precise jabs. Extremely consistent and hard to dodge.' },
  backstab:     { name:'Backstab',        dmgType:'physical', stat:'spd', fixed:5,  dice:[2,6],  acc:0,  uses:8,  desc:'Strike from shadows. High variance — massive hit or barely a scratch.' },
  ragingBlow:   { name:'Raging Blow',     dmgType:'physical', stat:'atk', fixed:4,  dice:[2,8],  acc:-1, uses:5,  desc:'Berserk overhand strike. Maximum variance — true feast or famine.' },
  flurry:       { name:'Flurry of Blows', dmgType:'physical', stat:'spd', fixed:9,  dice:[1,4],  acc:1,  uses:20, desc:'Rapid combination strikes. Very consistent and reliable.' },
  crossbow:     { name:'Crossbow Shot',   dmgType:'physical', stat:'spd', fixed:7,  dice:[1,8],  acc:1,  uses:15, desc:'Precise ranged bolt. Moderate variance, good accuracy.' },
  // MAGICAL
  arcaneBolt:   { name:'Arcane Bolt',     dmgType:'magical',  stat:'int', fixed:9,  dice:[1,4],  acc:1,  uses:20, desc:'Focused arcane energy. Consistent and reliable.' },
  arcaneBarrage:{ name:'Arcane Barrage',  dmgType:'magical',  stat:'int', fixed:7,  dice:[1,8],  acc:0,  uses:10, desc:'Volley of magical projectiles. Moderate variance.' },
  disintegrate: { name:'Disintegrate',    dmgType:'magical',  stat:'int', fixed:5,  dice:[2,6],  acc:-1, uses:4,  desc:'Beam of pure destruction. Can obliterate or fizzle.' },
  arcaneMissile:{ name:'Arcane Missiles', dmgType:'magical',  stat:'int', fixed:7,  dice:[1,4],  acc:99, uses:15, desc:'Unerring bolts. Always hits, always consistent. Lower damage for guaranteed value.' },
  chaosBolt:    { name:'Chaos Bolt',      dmgType:'magical',  stat:'cha', fixed:5,  dice:[2,6],  acc:0,  uses:8,  desc:'Unstable magical energy. High variance chaotic damage.' },
  kiBlast:      { name:'Ki Blast',        dmgType:'magical',  stat:'def', fixed:7,  dice:[1,8],  acc:0,  uses:16, desc:'Focused spiritual energy. Moderate variance.' },
  fireBolt:     { name:'Fire Bolt',       dmgType:'magical',  stat:'int', fixed:9,  dice:[1,4],  acc:1,  uses:20, desc:'Small bolt of flame. Consistent elemental damage.' },
  lightning:    { name:'Lightning Strike', dmgType:'magical',  stat:'int', fixed:7,  dice:[1,8],  acc:0,  uses:10, desc:'Crackling bolt. Moderate variance, same average.' },
  meteor:       { name:'Meteor Strike',   dmgType:'magical',  stat:'int', fixed:5,  dice:[2,6],  acc:-1, uses:4,  desc:'Call down a meteor. High variance — devastating or disappointing.' },
  iceShards:    { name:'Ice Shards',      dmgType:'magical',  stat:'int', fixed:5,  dice:[1,6],  acc:1,  uses:15, desc:'Razor-sharp ice. Lower damage but may slow the target.', effect:'slow' },
  thornWhip:    { name:'Thorn Whip',      dmgType:'magical',  stat:'def', fixed:9,  dice:[1,4],  acc:1,  uses:20, desc:'Thorny vine lash. Reliable nature damage.' },
  earthquake:   { name:'Earthquake',      dmgType:'magical',  stat:'def', fixed:5,  dice:[2,6],  acc:-1, uses:5,  desc:'Shake the ground. High variance in impact.' },
  naturesWrath: { name:"Nature's Wrath",  dmgType:'magical',  stat:'def', fixed:7,  dice:[1,8],  acc:0,  uses:12, desc:'Channel nature fury. Moderate variance, solid damage.' },
  // SOUL
  sacredFlame:  { name:'Sacred Flame',    dmgType:'soul',     stat:'def', fixed:9,  dice:[1,4],  acc:1,  uses:20, desc:'Steady beam of holy light. Consistent divine damage.' },
  guidingBolt:  { name:'Guiding Bolt',    dmgType:'soul',     stat:'def', fixed:7,  dice:[1,8],  acc:1,  uses:10, desc:'Brilliant divine bolt. Good accuracy, moderate variance.' },
  judgment:     { name:'Divine Judgment',  dmgType:'soul',     stat:'def', fixed:5,  dice:[2,6],  acc:-1, uses:4,  desc:'Heavenly wrath. High variance — glorious or disappointing.' },
  smite:        { name:'Divine Smite',    dmgType:'soul',     stat:'atk', fixed:7,  dice:[1,8],  acc:0,  uses:10, desc:'Channel divine power through your blade. Moderate variance.' },
  holyNova:     { name:'Holy Nova',       dmgType:'soul',     stat:'def', fixed:5,  dice:[2,6],  acc:0,  uses:6,  desc:'Explosion of sacred energy. High variance burst.' },
  moonfire:     { name:'Moonfire',        dmgType:'soul',     stat:'def', fixed:7,  dice:[1,8],  acc:0,  uses:16, desc:'Burn with moonlight. Moderate consistency.' },
  shadowBolt:   { name:'Shadow Bolt',     dmgType:'soul',     stat:'int', fixed:9,  dice:[1,4],  acc:1,  uses:20, desc:'Bolt of dark energy. Reliable curse damage.' },
  lifeDrain:    { name:'Life Drain',      dmgType:'soul',     stat:'cha', fixed:5,  dice:[1,8],  acc:0,  uses:12, desc:'Siphon vitality. Lower damage but heals for half dealt.', drain:0.4 },
  deathCoil:    { name:'Death Coil',      dmgType:'soul',     stat:'cha', fixed:5,  dice:[2,6],  acc:-1, uses:5,  desc:'Coil of death magic. High variance.' },
  hexBolt:      { name:'Hex Bolt',        dmgType:'soul',     stat:'cha', fixed:5,  dice:[1,6],  acc:0,  uses:15, desc:'Cursed projectile. Lower damage but may poison.', effect:'poison' },
  poisonBlade:  { name:'Poisoned Blade',  dmgType:'soul',     stat:'spd', fixed:5,  dice:[1,6],  acc:1,  uses:15, desc:'Envenomed weapon. Lower damage but may poison.', effect:'poison' },
  eldritchBlast:{ name:'Eldritch Blast',  dmgType:'soul',     stat:'cha', fixed:7,  dice:[1,8],  acc:0,  uses:10, desc:'Crackling dark energy. Moderate variance.' },
  darkNova:     { name:'Dark Nova',       dmgType:'soul',     stat:'cha', fixed:5,  dice:[2,6],  acc:-1, uses:4,  desc:'Catastrophic dark energy. High variance.' },
  // HEALS — fixed + dice, same system
  layOnHands:   { name:'Lay on Hands',   dmgType:'heal', stat:'cha', fixed:8,  dice:[1,6],  acc:99, uses:4, desc:'Channel divine healing through touch.', heal:true },
  cureWounds:   { name:'Cure Wounds',    dmgType:'heal', stat:'def', fixed:8,  dice:[1,6],  acc:99, uses:5, desc:'Mend wounds with healing magic.', heal:true },
  secondWind:   { name:'Second Wind',    dmgType:'heal', stat:'con', fixed:5,  dice:[2,6],  acc:99, uses:3, desc:'Rally through sheer willpower. Swingy heal.', heal:true },
  herbalRemedy: { name:'Herbal Remedy',  dmgType:'heal', stat:'def', fixed:8,  dice:[1,4],  acc:99, uses:4, desc:'Apply soothing healing herbs.', heal:true },
  meditation:   { name:'Meditation',     dmgType:'heal', stat:'def', fixed:7,  dice:[1,8],  acc:99, uses:4, desc:'Focus inner energy to heal.', heal:true },
  darkPact:     { name:'Dark Pact',      dmgType:'heal', stat:'cha', fixed:8,  dice:[1,4],  acc:99, uses:4, desc:'Sacrifice dark energy to restore health.', heal:true },
  rejuvenation: { name:'Rejuvenation',   dmgType:'heal', stat:'def', fixed:9,  dice:[1,4],  acc:99, uses:5, desc:'Nature\'s restorative power. Very consistent.', heal:true },
  manaShield:   { name:'Mana Shield',    dmgType:'heal', stat:'int', fixed:7,  dice:[1,8],  acc:99, uses:4, desc:'Convert magical energy into healing.', heal:true },
  // LICH ABILITIES
  lichBlast:    { name:'Lich Blast',      dmgType:'magical',  stat:'int', fixed:8,  dice:[2,6],  acc:0,  uses:14, desc:'Concentrated necrotic-arcane blast. High damage with a chance to freeze.', freezeChance:0.2 },
  glaciate:     { name:'Glaciate',        dmgType:'magical',  stat:'int', fixed:6,  dice:[1,4],  acc:1,  uses:16, desc:'Wave of absolute cold. Low damage but very high freeze chance.', freezeChance:0.6 },
  lichLifeDrain:{ name:'Life Drain',      dmgType:'magical',  stat:'int', fixed:7,  dice:[1,8],  acc:0,  uses:10, desc:'Siphon life force from the target. Heals proportion of damage dealt.', drain:0.4 },
  shatter:      { name:'Shatter',         dmgType:'soul', stat:'int', fixed:18, dice:[2,6],  acc:1,  uses:6,  desc:'Shatter the frozen soul. High soul damage — bypasses all defences. ONLY works on frozen enemies.', requiresFrozen:true },
  // PIT DWELLER ABILITIES
  tumpUp:       { name:'Tump Up',        dmgType:'physical', stat:'atk', fixed:4,  dice:[1,6],  acc:1,  uses:16, desc:'Hits twice. Second hit deals more damage but can miss.', doubleHit:true },
  counterThrow: { name:'Counter Throw',  dmgType:'physical', stat:'atk', fixed:6,  dice:[1,6],  acc:0,  uses:10, desc:'Act with reduced speed. Deals 75% bonus damage if opponent already hit you this turn.', counterMove:true },
  subdue:       { name:'Subdue',         dmgType:'physical', stat:'atk', fixed:11, dice:[1,6],  acc:1,  uses:12, desc:'Pin the opponent down. Prevents them from switching next turn.', lockSwitch:true },
  deathLust:    { name:'Death Lust',     dmgType:'physical', stat:'atk', fixed:6,  dice:[1,4],  acc:99, uses:4,  desc:'Enter a frenzy. Adds +4 flat soul damage per hit for 2 turns. Lost on switching.', grantDeathLust:true },
  // SIR SHINING ABILITIES
  radialStrike: { name:'Radial Strike',  dmgType:'physical', stat:'atk', fixed:8,  dice:[1,6],  acc:1,  uses:16, desc:'Sweeping holy blade strike. Chance to apply a stack of blind.', blindChance:0.4 },
  makeWay:      { name:'Make Way',       dmgType:'physical', stat:'atk', fixed:5,  dice:[1,4],  acc:99, uses:6,  desc:'Charge with massive speed boost and DEF bonus for the turn, then switch out at end of turn.', makeWay:true },
  heavenlyBlow: { name:'Heavenly Blow',  dmgType:'physical', stat:'atk', fixed:7,  dice:[1,8],  acc:0,  uses:10, desc:'Half physical, half magical damage. Hits both defences.', splitDamage:true },
  healingPrayer:{ name:'Healing Prayer', dmgType:'heal',     stat:'cha', fixed:0,  dice:[1,1],  acc:99, uses:4,  desc:'Pray for healing. Instantly heals 25% max HP and cures all statuses.', healingPrayer:true, heal:true },
  // REX RANG ABILITIES
  battlerang:   { name:'Battlerang',     dmgType:'physical', stat:'atk', fixed:8,  dice:[1,6],  acc:0,  uses:14, desc:'Medium physical damage. Boomerangs back — hits again at end of next turn. Chance to flinch (target loses action).', boomerang:true, flinchChance:0.25 },
  emberang:     { name:'Emberang',       dmgType:'physical', stat:'atk', fixed:5,  dice:[1,6],  acc:0,  uses:12, desc:'Less damage than Battlerang but chance to burn. Hits again at end of next turn.', boomerang:true, burnChance:0.35 },
  whittle:      { name:'Whittle',        dmgType:'physical', stat:'atk', fixed:4,  dice:[1,4],  acc:99, uses:4,  desc:'Sharpen your edge. Grants +4 ATK until you switch out.', grantWhittle:true },
  swerve:       { name:'Swerve',         dmgType:'physical', stat:'atk', fixed:0,  dice:[1,1],  acc:99, uses:10, desc:'Act fast and dodge. High chance to evade enemy attacks this turn. Much less effective if used consecutively.', swerve:true },
  // COUNT COCTION ABILITIES
  poisonDart:   { name:'Poison Dart',    dmgType:'physical', stat:'atk', fixed:7,  dice:[1,6],  acc:0,  uses:14, desc:'Quick physical strike. Always adds 2 stacks of poison (3 with Rapid Transmission).', poisonChance:1.00, poisonStacks:2 },
  goblinGas:    { name:'Goblin Gas',     dmgType:'physical', stat:'atk', fixed:0,  dice:[1,1],  acc:99, uses:4,  desc:'Deploy a poison gas cloud. Both fighters gain a poison stack each turn for 5 turns. Replaces existing terrain.', goblinGas:true },
  remedialOintment:{ name:'Remedial Ointment', dmgType:'heal', stat:'cha', fixed:0, dice:[1,1], acc:99, uses:6, desc:'Remove all poison from yourself and heal 9 HP per stack removed.', remedialOintment:true, heal:true },
  violentExtraction:{ name:'Violent Extraction', dmgType:'soul', stat:'atk', fixed:0, dice:[1,1], acc:99, uses:6, desc:'Rip all poison from the enemy. Deals 15 soul damage per stack removed.', violentExtraction:true },
  // VINY THE YOUNGER ABILITIES
  petalStorm:   { name:'Petal Storm',    dmgType:'magical',  stat:'int', fixed:5,  dice:[1,4],  acc:0,  uses:14, desc:'Whirl of sharp petals. Small magic damage with 50% chance (+CHA) to apply a blind stack.', petalStorm:true, blindChance:0.50 },
  battleBoar:   { name:'Battle Boar',    dmgType:'physical', stat:'int', fixed:0,  dice:[1,1],  acc:99, uses:2,  desc:'Summon a Battle Boar to replace you. Reduced speed — you take a hit first. The boar fights in your place but dies if switched out.', summonBoar:true, reducedPriority:true },
  ancientPower: { name:'Ancient Power',  dmgType:'magical',  stat:'int', fixed:15, dice:[2,6],  acc:0,  uses:6,  desc:'Channel ancient magic. Deals high magic damage at the end of 2 turns.', ancientPower:true },
  transference: { name:'Transference',   dmgType:'soul',     stat:'int', fixed:0,  dice:[1,1],  acc:99, uses:4,  desc:'Transfer all your status effects and stacks to the enemy. Ignores frozen inaction.', transference:true },
  // BATTLE BOAR ABILITIES
  headbutt:     { name:'Headbutt',       dmgType:'physical', stat:'atk', fixed:6,  dice:[1,4],  acc:0,  uses:20, desc:'Ram your head into the enemy. Low damage but 25% chance to flinch.', flinchChance:0.25 },
  chomp:        { name:'Chomp',          dmgType:'physical', stat:'atk', fixed:4,  dice:[1,4],  acc:0,  uses:20, desc:'Bite down hard. Low damage but applies a stack of Wounded.', chomp:true },
  // JAH APOSTLE ABILITIES
  moonlight:     { name:'Moonlight',       dmgType:'heal',     stat:'int', fixed:0,  dice:[1,1],  acc:99, uses:8,  desc:'Channel moonlight. Heals self for 25% max HP. The next ally to switch in is also healed for the same amount.', moonlight:true, heal:true },
  readScripture: { name:'Read Scripture',  dmgType:'soul',     stat:'int', fixed:10, dice:[1,8],  acc:0,  uses:14, desc:'Medium soul damage. Variable curse stacks: 50% none, 25% one, 15% two, 10% three.', readScripture:true },
  riot:          { name:'Riot',           dmgType:'soul',     stat:'int', fixed:5,  dice:[1,4],  acc:0,  uses:12, desc:'Low soul damage. Applies 2 curse stacks and 1 burn stack.', riot:true },
  lookAtMe:      { name:'Look at Me',     dmgType:'soul',     stat:'cha', fixed:0,  dice:[1,1],  acc:99, uses:6,  desc:'Prevent the target from switching this turn. If they try, your team gains a 2-turn shield.', lookAtMe:true },
  // LEXILAS ABILITIES
  recklessSwing: { name:'Reckless Swing', dmgType:'physical', stat:'atk', fixed:14, dice:[2,6], acc:0, uses:10, desc:'Devastating overhead swing. Deals 10% of damage dealt as recoil to self.', recklessSwing:true },
  eviscerate:    { name:'Eviscerate',      dmgType:'physical', stat:'atk', fixed:7,  dice:[1,6], acc:0, uses:14, desc:'Slash deep. Medium physical damage. Applies a stack of Wounded (bonus soul damage after being hit, switching removes 1 stack).', eviscerate:true },
  lexShieldBash: { name:'Shield Bash',    dmgType:'physical', stat:'atk', fixed:6,  dice:[1,4], acc:1, uses:16, desc:'Brace with your shield then strike. Gain DEF, lose SPD for the turn. 35% chance to stun.', shieldBash:true, stunChance:0.35 },
  chivalry:      { name:'Chivalry',       dmgType:'heal',     stat:'def', fixed:0,  dice:[1,1], acc:99, uses:6, desc:'Honour the duel. Always goes last. Heals 30% max HP if Lexilas didn\'t take damage this turn.', chivalry:true, heal:true },
};

// ============================================================
//  CLASSES (12 classes, grouped by primary type)
// ============================================================
const NAMES = {
  knight:['Aldric','Seraphina','Theron','Isolde','Cedric','Elara','Baelin','Valor'],
  mage:['Mordecai','Lyra','Thalindra','Orion','Vesper','Zephyra','Sylas','Arcana'],
  elementalist:['Pyralis','Ember','Storm','Ignis','Solara','Vortex','Nova','Flux'],
  paladin:['Galadriel','Ansel','Torin','Sera','Lumiel','Briar','Faith','Hallam'],
  warlock:['Zarvox','Selene','Grimshaw','Noctis','Vashti','Hex','Faust','Bane'],
  berserker:['Grukk','Brynhild','Ragnar','Uthgar','Korra','Wulfric','Throgg','Bjorn'],
  cleric:['Maren','Devyn','Ansel','Sera','Hallam','Lumiel','Briar','Faith'],
  necromancer:['Malachar','Lilith','Thanatos','Morgana','Dredge','Viessa','Umbra','Corvus'],
  druid:['Oakhart','Willow','Bramble','Fern','Rowan','Moss','Thorn','Ashenbark'],
  sorcerer:['Caspian','Nova','Pyralis','Vortex','Ember','Storm','Solara','Flux'],
  assassin:['Shade','Nyx','Vex','Raven','Kael','Silka','Whisper','Dusk'],
  monk:['Kai','Yuki','Zen','Lotus','Jin','Sora','Ryu','Bodhi'],
  lich:['Malachar','Xyranthos','Vek\'thar','Osseus','Dreadhollow','Lichtar','Nekros','Morvaine'],
  ranger:['Rex','Ranger','Scout','Hawk','Flint','Arrow','Tracker','Swift'],
  rogue:['Count','Shadow','Vex','Nyx','Shade','Whisper','Dusk','Gobbo'],
};

const CLASSES = [
  { id:'knight', label:'Knight', color:'#c4a832',
    stats:{atk:16,spd:10,con:15,int:8,def:12,cha:14},
    abilities:['swordSlash','shieldBash','execute','layOnHands'], sprite:'knight' },
  { id:'mage', label:'Mage', color:'#5577cc',
    stats:{atk:8,spd:14,con:10,int:18,def:12,cha:10},
    abilities:['arcaneBolt','arcaneBarrage','disintegrate','manaShield'], sprite:'wizard' },
  { id:'elementalist', label:'Elementalist', color:'#dd6633',
    stats:{atk:8,spd:12,con:11,int:17,def:13,cha:12},
    abilities:['fireBolt','lightning','meteor','manaShield'], sprite:'sorcerer' },
  { id:'paladin', label:'Paladin', color:'#ddaa33',
    stats:{atk:16,spd:10,con:14,int:8,def:14,cha:15},
    abilities:['smite','guidingBolt','judgment','layOnHands'], sprite:'knight' },
  { id:'warlock', label:'Warlock', color:'#884488',
    stats:{atk:8,spd:14,con:12,int:12,def:10,cha:18},
    abilities:['hexBolt','eldritchBlast','darkNova','darkPact'], sprite:'warlock' },
  { id:'berserker', label:'Berserker', color:'#aa4422',
    stats:{atk:18,spd:12,con:16,int:6,def:8,cha:10},
    abilities:['cleave','ragingBlow','execute','secondWind'], sprite:'barbarian' },
  { id:'cleric', label:'Cleric', color:'#ccaa44',
    stats:{atk:14,spd:8,con:14,int:10,def:18,cha:12},
    abilities:['sacredFlame','holyNova','judgment','cureWounds'], sprite:'cleric' },
  { id:'necromancer', label:'Necromancer', color:'#663366',
    stats:{atk:6,spd:12,con:10,int:16,def:14,cha:14},
    abilities:['shadowBolt','lifeDrain','deathCoil','darkPact'], sprite:'necro' },
  { id:'druid', label:'Druid', color:'#558844',
    stats:{atk:10,spd:12,con:14,int:12,def:17,cha:10},
    abilities:['thornWhip','naturesWrath','earthquake','rejuvenation'], sprite:'druid' },
  { id:'sorcerer', label:'Sorcerer', color:'#cc5533',
    stats:{atk:8,spd:14,con:12,int:14,def:10,cha:18},
    abilities:['chaosBolt','arcaneBarrage','disintegrate','manaShield'], sprite:'sorcerer' },
  { id:'assassin', label:'Assassin', color:'#607070',
    stats:{atk:10,spd:18,con:12,int:14,def:10,cha:12},
    abilities:['quickStrike','backstab','poisonBlade','herbalRemedy'], sprite:'rogue' },
  { id:'ranger', label:'Ranger', color:'#aa8844',
    stats:{atk:10,spd:17,con:12,int:10,def:16,cha:8},
    abilities:['flurry','kiBlast','execute','meditation'], sprite:'monk' },
  { id:'sirShining', label:'Paladin', fixedName:'Sir Shining', color:'#ddcc44',
    statWeights:{atk:3,spd:1,con:3,int:1.5,def:4,cha:3.5},
    abilities:['radialStrike','makeWay','heavenlyBlow','healingPrayer'], sprite:'knight',
    stances: [
      { id:'battlefieldStar', name:'Battlefield Star', desc:'CHA+2. Chance to apply blind stack to opponent each turn.',
        statBoosts:{cha:2}, passive:'blindPerTurn' },
      { id:'flashyArrival', name:'Flashy Arrival', desc:'DEF+2. Applies 2 stacks of blind to opponent upon selection.',
        statBoosts:{def:2}, passive:'flashyBlind' },
    ]},
  { id:'pitDweller', label:'Berserker', fixedName:'Pit Dweller', color:'#8a4422',
    statWeights:{atk:4,spd:1.5,con:3,int:0.5,def:2,cha:1},
    abilities:['tumpUp','counterThrow','subdue','deathLust'], sprite:'barbarian',
    stances: [
      { id:'dirtyBoxing', name:'Dirty Boxing', desc:'CON+2. Dealing damage has a chance to stun opponent.',
        statBoosts:{con:2}, passive:'stunOnHit' },
      { id:'pitVeteran', name:'Pit Veteran', desc:'DEF+2. Small regen at end of each turn.',
        statBoosts:{def:2}, passive:'regenTick' },
    ]},
  { id:'lich', label:'Mage', fixedName:'Lich King', color:'#44ccdd',
    statWeights:{atk:0.5,spd:1.5,con:1.5,int:5,def:2.5,cha:3},
    abilities:['lichBlast','glaciate','lichLifeDrain','shatter'], sprite:'lich',
    stances: [
      { id:'arcticAura', name:'Arctic Aura', desc:'CON+2, CHA+2. Adds 10% freeze chance to ALL moves.',
        statBoosts:{con:2,cha:2}, passive:'freezeAll' },
      { id:'soulSnatcher', name:'Soul Snatcher', desc:'INT+2. Heals 10% of damage dealt on all attacks.',
        statBoosts:{int:2}, passive:'attackLifesteal' },
    ]},
  { id:'rexRang', label:'Ranger', fixedName:'Rex Rang', color:'#6b8e23',
    statWeights:{atk:5.5,spd:3,con:3,int:0.5,def:2,cha:1},
    abilities:['battlerang','emberang','whittle','swerve'], sprite:'ranger',
    stances: [
      { id:'patientKiller', name:'Patient Killer', desc:'ATK+2. Second hit of Battlerang/Emberang deals bonus damage.',
        statBoosts:{atk:2}, passive:'boomerangBonus' },
      { id:'guerillaFighter', name:'Guerilla Fighter', desc:'SPD+2. On switch-in, throws a 30% power Battlerang. After dodging with Swerve, switch out.',
        statBoosts:{spd:2}, passive:'guerillaSwitchOut', guerillaEntry:true },
    ]},
  { id:'countCoction', label:'Rogue', fixedName:'Count Coction', color:'#5a8a3a',
    statWeights:{atk:4,spd:4,con:3,int:0.5,def:2,cha:1.5},
    abilities:['poisonDart','goblinGas','remedialOintment','violentExtraction'], sprite:'rogue',
    stances: [
      { id:'rapidTransmission', name:'Rapid Transmission', desc:'CHA+2. When an enemy gains a poison stack, 30% chance (+CHA) they gain an extra one.',
        statBoosts:{cha:2}, passive:'rapidTransmission' },
      { id:'neurotoxin', name:'Neurotoxin', desc:'SPD+2. Poisoned enemies lose 1 INT per poison stack.',
        statBoosts:{spd:2}, passive:'neurotoxin' },
    ]},
  { id:'viny', label:'Druid', fixedName:'Viny the Younger', color:'#3a7a3a',
    statWeights:{atk:0.5,spd:1,con:1,int:3.5,def:1.5,cha:2},
    abilities:['petalStorm','battleBoar','ancientPower','transference'], sprite:'druid',
    stances: [
      { id:'overgrowth', name:'Overgrowth', desc:'INT+2. On switch-in, adds Vine terrain for 5 turns. Vines squeeze the first mover each turn for fixed damage.',
        statBoosts:{int:2}, passive:'overgrowth', overgrowthEntry:true },
      { id:'restoration', name:'Restoration', desc:'CON+2. Heals 20% max HP upon switch-out.',
        statBoosts:{con:2}, passive:'restoration' },
    ]},
  { id:'battleBoar', label:'Boar', fixedName:'Battle Boar', color:'#8a6633', isSummon:true,
    stats:{atk:8,spd:12,con:8,int:5,def:6,cha:5},
    abilities:['headbutt','chomp'], sprite:'barbarian',
    stances: [
      { id:'prickly', name:'Prickly', desc:'Enemies attacking you take 1 damage.',
        statBoosts:{}, passive:'prickly' },
    ]},
  { id:'jahApostle', label:'Cleric', fixedName:'Jah Apostle', color:'#9966cc',
    statWeights:{atk:0.5,spd:1,con:2,int:3.5,def:2,cha:3},
    abilities:['moonlight','readScripture','riot','lookAtMe'], sprite:'cleric',
    stances: [
      { id:'gekyumesBlessing', name:"Gekyume's Blessing", desc:'INT+2. Healing and shields are boosted by 30%.',
        statBoosts:{int:2}, passive:'healBoost' },
      { id:'forbiddenSermon', name:'Forbidden Sermon', desc:'CHA+2. At the end of each turn, apply 2 stacks of Curse to the opponent.',
        statBoosts:{cha:2}, passive:'cursePerTurn' },
    ]},
  { id:'lexilas', label:'Warrior', fixedName:'Lexilas', color:'#c4a035',
    statWeights:{atk:4,spd:2,con:3.5,int:0.5,def:3,cha:1},
    abilities:['recklessSwing','eviscerate','lexShieldBash','chivalry'], sprite:'warrior',
    stances: [
      { id:'overwhelming', name:'Overwhelming', desc:'ATK+3. Enemy stance passive is suppressed while Lexilas is active.',
        statBoosts:{atk:3}, passive:'overwhelming' },
      { id:'duelist', name:'Duelist', desc:'DEF+2. Gain +5 ATK on hit. Lasts until switch-out or next attack. Can stack.',
        statBoosts:{def:2}, passive:'duelist' },
    ]},
];

// Generate default stances for classes that don't have them
const DEFAULT_STANCES = {
  knight: [
    { id:'ironGuard', name:'Iron Guard', desc:'CON+2. Defensive and sturdy.', statBoosts:{con:2}, passive:'none' },
    { id:'aggressor', name:'Aggressor', desc:'ATK+2, SPD+1. Offense-focused.', statBoosts:{atk:2,spd:1}, passive:'none' },
  ],
  mage: [
    { id:'arcaneFlow', name:'Arcane Flow', desc:'INT+2. Enhances spell potency.', statBoosts:{int:2}, passive:'none' },
    { id:'ward', name:'Arcane Ward', desc:'CON+2, DEF+1. Better survivability.', statBoosts:{con:2,def:1}, passive:'none' },
  ],
  elementalist: [
    { id:'stormcaller', name:'Stormcaller', desc:'INT+2. Raw elemental power.', statBoosts:{int:2}, passive:'none' },
    { id:'stoneskin', name:'Stoneskin', desc:'CON+3. Earthen resilience.', statBoosts:{con:3}, passive:'none' },
  ],
  paladin: [
    { id:'crusader', name:'Crusader', desc:'ATK+2, CHA+1. Righteous fury.', statBoosts:{atk:2,cha:1}, passive:'none' },
    { id:'protector', name:'Protector', desc:'CON+2, DEF+1. Divine shield.', statBoosts:{con:2,def:1}, passive:'none' },
  ],
  warlock: [
    { id:'hexmaster', name:'Hexmaster', desc:'CHA+2. Stronger curses.', statBoosts:{cha:2}, passive:'none' },
    { id:'darkResilience', name:'Dark Resilience', desc:'CON+2, INT+1. Pact-fueled endurance.', statBoosts:{con:2,int:1}, passive:'none' },
  ],
  berserker: [
    { id:'bloodrage', name:'Blood Rage', desc:'ATK+3. Unrelenting fury.', statBoosts:{atk:3}, passive:'none' },
    { id:'ironSkin', name:'Iron Skin', desc:'CON+2, SPD+1. Tough as nails.', statBoosts:{con:2,spd:1}, passive:'none' },
  ],
  cleric: [
    { id:'radiance', name:'Radiance', desc:'DEF+2. Brighter divine power.', statBoosts:{def:2}, passive:'none' },
    { id:'bulwark', name:'Bulwark', desc:'CON+2, ATK+1. Armored faith.', statBoosts:{con:2,atk:1}, passive:'none' },
  ],
  necromancer: [
    { id:'deathGrasp', name:'Death Grasp', desc:'INT+2. Stronger death magic.', statBoosts:{int:2}, passive:'none' },
    { id:'undeadFortitude', name:'Undead Fortitude', desc:'CON+2, CHA+1. Undying resilience.', statBoosts:{con:2,cha:1}, passive:'none' },
  ],
  druid: [
    { id:'wildGrowth', name:'Wild Growth', desc:'DEF+2. Nature amplified.', statBoosts:{def:2}, passive:'none' },
    { id:'barkArmor', name:'Bark Armor', desc:'CON+3. Living wood protection.', statBoosts:{con:3}, passive:'none' },
  ],
  sorcerer: [
    { id:'wildMagic', name:'Wild Magic', desc:'CHA+2. Amplified chaos.', statBoosts:{cha:2}, passive:'none' },
    { id:'focusedMind', name:'Focused Mind', desc:'INT+2, CON+1. Controlled sorcery.', statBoosts:{int:2,con:1}, passive:'none' },
  ],
  assassin: [
    { id:'shadowStep', name:'Shadow Step', desc:'SPD+2. Swift and deadly.', statBoosts:{spd:2}, passive:'none' },
    { id:'venomous', name:'Venomous', desc:'CON+2, INT+1. Toxin expertise.', statBoosts:{con:2,int:1}, passive:'none' },
  ],
  monk: [
    { id:'innerFire', name:'Inner Fire', desc:'SPD+2. Lightning reflexes.', statBoosts:{spd:2}, passive:'none' },
    { id:'ironBody', name:'Iron Body', desc:'CON+2, DEF+1. Hardened body and mind.', statBoosts:{con:2,def:1}, passive:'none' },
  ],
};
CLASSES.forEach(c => { if (!c.stances) c.stances = DEFAULT_STANCES[c.id] || null; });

// ============================================================
//  SPRITES
// ============================================================
const SPRITES = {
  knight:    ['...xxxx...','..xxxxxx..','..xxxxxx..','...xxxx...','..xxxxxx..','.xxxxxxxx.','.xxxxxxxx.','..xxxxxx..','..xx..xx..','..xx..xx..'],
  wizard:    ['....xx....','...xxxx...','..xxxxxx..','...xxxx...','...xxxx...','..xxxxxx..','..xxxxxx..','..xxxxxx..','...x..x...','...x..x...'],
  rogue:     ['...xxx....','..xxxxx...','..xxxxx...','...xxx....','..xxxxx...','..xxxxx...','..xxxxx...','...xxx....','..xx.xx...','..x...x...'],
  barbarian: ['..xxxxx...','..xxxxx...','..xxxxx...','...xxx....','.xxxxxxx..','xxxxxxxxx.','.xxxxxxx..','..xxxxx...','..xx.xx..','.xxx.xxx..'],
  necro:     ['...xxxx...','..xxxxxx..','..xxxxxx..','...xxxx...','..xxxxxx..','.xxxxxxxx.','..xxxxxx..','...xxxx...','...xx.x...','...x..x...'],
  cleric:    ['....xx....','...xxxx...','...xxxx...','...xxxx...','..xxxxxx..','.xxxxxxxx.','..xxxxxx..','..xxxxxx..','..xx..xx..','..xx..xx..'],
  warlock:   ['..x.xx.x..','..xxxxxx..','..xxxxxx..','...xxxx...','..xxxxxx..','.xxxxxxxx.','..xxxxxx..','..xxxxxx..','...x..x...','...x..x...'],
  druid:     ['.xxx.xxx..','..xxxxxx..','..xxxxxx..','...xxxx...','..xxxxxx..','..xxxxxx..','..xxxxxx..','...xxxx...','..xx..xx..','..x....x..'],
  sorcerer:  ['...xxxx...','..xxxxxx..','..xxxxxx..','...xxxx...','..xxxxxx..','.xxxxxxxx.','..xxxxxx..','..xxxxxx..','...x..x...','...x..x...'],
  monk:      ['....xx....','...xxxx...','...xxxx...','...xxxx...','..xxxxxx..','..xxxxxx..','..xxxxxx..','...xxxx...','..xx..xx..','..x....x..'],
  ranger:    ['...xxx....','..xxxxx...','..xxxxx...','...xxx....','..xxxx.x..','.xxxxx.x..','..xxxx.x..','...xxx....','..xx..xx..','..x....x..'],
  lich:      ['..x.xx.x..','...xxxx...','..xxxxxx..','..xxxxxx..','...xxxx...','.xxxxxxxx.','..xxxxxx..','..xxxxxx..','...x..x...','..xx..xx..'],
  warrior:   ['...xxxx...','..xxxxxx..','..xxxxxx..','...xxxx...','.xxxxxxxx.','xxxxxxxxxx','.xxxxxxxx.','..xxxxxx..','..xx..xx..','.xxx..xxx.'],
  boar:      ['..........','..xxx.....','..xxxxx...','.xxxxxxx..','xxxxxxxxx.','xxxxxxxxxx','.xxxxxxxx.','..xxxxxx..','..xx..xx..','..xx..xx..'],
};
SPRITES.fighter = SPRITES.knight;

function drawSprite(canvas, spriteKey, color, flipped) {
  const ctx = canvas.getContext('2d'); const w = canvas.width, h = canvas.height;
  ctx.clearRect(0, 0, w, h);
  const shape = SPRITES[spriteKey] || SPRITES.knight;
  const gridH = shape.length, gridW = shape[0].length;
  const cellW = w / gridW, cellH = h / gridH;
  const dark = shadeColor(color, -40), light = shadeColor(color, 35);
  const seed = hashStr(spriteKey + color); const rng = mulberry32(seed);
  for (let y = 0; y < gridH; y++) {
    for (let x = 0; x < gridW; x++) {
      if (shape[y][x] !== 'x') continue;
      let c = color;
      if (y === 0 || shape[y-1]?.[x] !== 'x') c = dark;
      else if (x === 0 || shape[y][x-1] !== 'x') c = dark;
      else if (rng() > 0.7) c = light;
      if ((y === 2) && (x === 3 || x === 5)) c = '#fff';
      if ((y === 2) && (x === 4 || x === 6)) c = '#111';
      const drawX = flipped ? w - (x + 1) * cellW : x * cellW;
      ctx.fillStyle = c;
      ctx.fillRect(Math.floor(drawX), Math.floor(y * cellH), Math.ceil(cellW), Math.ceil(cellH));
    }
  }
}

// ============================================================
//  COMBAT ENGINE
// ============================================================
function calcHP(con, level) { return 10 + mod(con) + (level - 1) * Math.max(1, 6 + mod(con)); }

const STAT_BUDGET = 72, STAT_FLOOR = 5, STAT_CAP = 20;
const STAT_NAMES = ['atk','def','con','int','cha','spd'];

function generateStats(cls) {
  if (cls.stats) return {...cls.stats}; // fixed stats fallback
  const weights = cls.statWeights;
  const stats = {};
  STAT_NAMES.forEach(s => stats[s] = STAT_FLOOR);
  let pool = STAT_BUDGET - STAT_FLOOR * STAT_NAMES.length; // 42 points
  const totalWeight = STAT_NAMES.reduce((sum, s) => sum + (weights[s] || 1), 0);
  while (pool > 0) {
    let r = Math.random() * totalWeight;
    for (const s of STAT_NAMES) {
      r -= (weights[s] || 1);
      if (r <= 0) {
        if (stats[s] < STAT_CAP) { stats[s]++; pool--; }
        break;
      }
    }
  }
  return stats;
}

function createCombatant(cls, level) {
  const name = cls.fixedName || pick(NAMES[cls.id] || NAMES.knight);
  const stats = generateStats(cls);
  const hp = calcHP(stats.con, level);
  return {
    cls, name, level, 
    stats,
    baseStats: {...stats},
    currentHp: hp, maxHp: hp,
    abilities: cls.abilities.map(k => ({...ABILITIES[k], key:k, currentUses: ABILITIES[k].uses})),
    status: null, statusTurns: 0, fainted: false,
    stance: null, stances: cls.stances || null,
    switchLocked: false, deathLustTurns: 0, damagedThisTurn: false,
    blindStacks: 0, healingPrayerPending: false, makeWaySwitch: false, defBonusThisTurn: 0,
    boomerangHits: [], burnStacks: 0, swerveActive: false, swerveLastTurn: false, whittleBoost: 0, flinched: false, poisonStacks: 0,
    bladeTossCooldown: false, duelistStacks: 0, shieldBashActive: false, shieldBashDef: 0, shieldBashSpd: 0, woundedStacks: 0,
    justSwitchedIn: false, overwhelmSuppressed: false, chivalryPending: false,
    ancientPowerPending: [], // [{turnsLeft, attacker(ref), target(ref)}]
    isSummon: cls.isSummon || false, summonOwner: null, // for boar: who summoned it
    curseStacks: 0, shieldTurns: 0, shieldHp: 0, lookAtMeLocked: false, // Cleric mechanics
  };
}

function attackRoll(attacker, ability, defenderDEF) {
  if (ability.acc === 99) return { hit: true, nat: 10, total: 99, crit: false };
  const statMod = mod(attacker.stats[ability.stat]);
  const prof = Math.floor(attacker.level / 4) + 2;
  const nat = d(20);
  const total = nat + statMod + prof + (ability.acc || 0);
  const crit = nat === 20;
  return { hit: nat === 20 || total >= defenderDEF, nat, total, crit };
}

function rollHealForAbility(attacker, ability) {
  const [count, sides] = ability.dice;
  return Math.max(1, (ability.fixed || 0) + rollDice(count, sides) + mod(attacker.stats[ability.stat]));
}

function rollDamageForAbility(attacker, defender, ability) {
  const [count, sides] = ability.dice;
  const baseDmg = (ability.fixed || 0) + rollDice(count, sides);
  // Physical: ATK vs DEF, Magical: INT vs INT, Soul: no scaling (raw dice only)
  if (ability.dmgType === 'soul') {
    return { damage: Math.max(1, baseDmg), baseDmg, atkRoll: 0, defRoll: 0, multiplier: 1.0 };
  }
  let atkStat, defStat;
  // Attack stat comes from ability.stat, defense stat from dmgType
  atkStat = attacker.stats[ability.stat] || attacker.stats.atk;
  if (ability.dmgType === 'physical') {
    defStat = defender.stats.def;
  } else {
    defStat = defender.stats.int;
  }
  // Neurotoxin: poisoned fighters lose 1 effective INT per stack
  if (defender.poisonStacks > 0 && ability.dmgType === 'magical') {
    // Check if any active opponent has neurotoxin stance
    const defIsPlayer = playerTeam.includes(defender);
    const opp = defIsPlayer ? opponent() : player();
    if (opp.stance?.passive === 'neurotoxin') {
      defStat = Math.max(1, defStat - defender.poisonStacks);
    }
  }
  // Also reduce attacker's INT if they're poisoned and enemy has neurotoxin
  if (attacker.poisonStacks > 0 && (ability.stat === 'int')) {
    const atkIsPlayer = playerTeam.includes(attacker);
    const opp = atkIsPlayer ? opponent() : player();
    if (opp.stance?.passive === 'neurotoxin') {
      atkStat = Math.max(1, atkStat - attacker.poisonStacks);
    }
  }
  const atkRoll = rollDice(2, 6) + atkStat;
  const defRoll = rollDice(2, 6) + defStat;
  const multiplier = 0.5 + 0.5 * (atkRoll / defRoll);
  const damage = Math.max(1, Math.floor(baseDmg * multiplier));
  return { damage, baseDmg, atkRoll, defRoll, multiplier };
}

function getInitiative(c) { const base = rollDice(2, 8) + c.stats.spd; if (c.status === 'frozen') return Math.floor(base * 0.4); if (c.status === 'stun') return Math.floor(base * 0.5); return base; }

// ============================================================
//  GAME STATE
// ============================================================
let playerTeam = [], oppTeam = [];
let playerActive = 0, oppActive = 0;
let terrain = null; // { name, turnsLeft, effect } — only one active at a time
let battleNum = 0, wins = 0, losses = 0;
let isAnimating = false, autoMode = false, autoTimer = null;

const logEl = document.getElementById('battle-log');
const moveButtonsEl = document.getElementById('move-buttons');
const tooltipEl = document.getElementById('tooltip');

function player() { return playerTeam[playerActive]; }
function opponent() { return oppTeam[oppActive]; }

function log(text, cls='') {
  const div = document.createElement('div');
  div.className = 'log-line ' + cls;
  div.textContent = text;
  logEl.appendChild(div);
  logEl.scrollTop = logEl.scrollHeight;
}

// ============================================================
//  UI RENDERING
// ============================================================
const STATUS_ICONS = { poison: '☠', stun: '⚡', slow: '🐌', frozen: '❄' };

function renderStatusEffects(b) {
  let html = '';
  if (b.status) {
    const icon = STATUS_ICONS[b.status] || '';
    const turnsLeft = b.status === 'frozen' ? '' : ` (${b.statusTurns}t)`;
    html += `<span class="status-effect-tag ${b.status}">${icon} ${b.status.toUpperCase()}${turnsLeft}</span>`;
  }
  if (b.blindStacks > 0) html += `<span class="status-effect-tag blind">😵 BLIND ×${b.blindStacks} (${b.blindStacks*15}% miss)</span>`;
  if (b.deathLustTurns > 0) html += `<span class="status-effect-tag" style="background:#4a1a1a;color:#e44">🔥 DEATH LUST (${b.deathLustTurns}t)</span>`;
  if (b.switchLocked) html += `<span class="status-effect-tag" style="background:#3a2a1a;color:#c86">📌 PINNED</span>`;
  if (b.healingPrayerPending) html += `<span class="status-effect-tag" style="background:#2a4a2a;color:#8c8">🙏 PRAYER PENDING</span>`;
  if (b.burnStacks > 0) html += `<span class="status-effect-tag" style="background:#4a2a0a;color:#f84">🔥 BURN ×${b.burnStacks}</span>`;
  if (b.poisonStacks > 0) html += `<span class="status-effect-tag" style="background:#2a4a1a;color:#6a4">☠ POISON ×${b.poisonStacks} (${b.poisonStacks * 2}/turn)</span>`;
  if (b.boomerangHits.length > 0) html += `<span class="status-effect-tag" style="background:#3a3a1a;color:#cc8">🪃 RANG INCOMING (${b.boomerangHits.length})</span>`;
  if (b.flinched) html += `<span class="status-effect-tag" style="background:#4a3a1a;color:#ea8">😵 FLINCHED</span>`;
  if (b.swerveActive) html += `<span class="status-effect-tag" style="background:#1a3a2a;color:#8c8">💨 SWERVING</span>`;
  if (b.whittleBoost > 0) html += `<span class="status-effect-tag" style="background:#3a2a1a;color:#ca8">🔪 WHETTED (+${b.whittleBoost} ATK)</span>`;
  if (b.woundedStacks > 0) html += `<span class="status-effect-tag" style="background:#4a1a2a;color:#e66">🩸 WOUNDED ×${b.woundedStacks}</span>`;
  if (b.curseStacks > 0) html += `<span class="status-effect-tag" style="background:#2a1a3a;color:#a6c">👁 CURSED ×${b.curseStacks}</span>`;
  if (b.shieldTurns > 0 && b.shieldHp > 0) html += `<span class="status-effect-tag" style="background:#1a2a4a;color:#6af">🛡 SHIELD ${b.shieldHp}HP (${b.shieldTurns}t)</span>`;
  if (b.lookAtMeLocked) html += `<span class="status-effect-tag" style="background:#3a1a3a;color:#c6a">🔒 LOCKED</span>`;
  return html ? `<div class="status-effects-row">${html}</div>` : '';
}

function updateHpBar(who) {
  const b = who === 'player' ? player() : opponent();
  const bar = document.getElementById(who === 'player' ? 'player-hp-bar' : 'opp-hp-bar');
  const text = document.getElementById(who === 'player' ? 'player-hp-text' : 'opp-hp-text');
  const pct = Math.max(0, b.currentHp / b.maxHp * 100);
  bar.style.width = pct + '%';
  bar.className = 'hp-bar' + (pct < 25 ? ' red' : pct < 50 ? ' yellow' : '');
  let hp = Math.max(0, b.currentHp) + ' / ' + b.maxHp;
  text.innerHTML = hp + renderStatusEffects(b);
}

function renderActiveInfo(who) {
  const b = who === 'player' ? player() : opponent();
  const prefix = who === 'player' ? 'player' : 'opp';
  document.getElementById(prefix + '-name').textContent = b.name;
  document.getElementById(prefix + '-class').textContent = b.cls.label;
  document.getElementById(prefix + '-level').textContent = 'Lv' + b.level;
  const s = b.stats;
  document.getElementById(prefix + '-stats').innerHTML =
    `<span>ATK ${s.atk}</span><span>DEF ${s.def}</span><span>CON ${s.con}</span><span>INT ${s.int}</span><span>CHA ${s.cha}</span><span>SPD ${s.spd}</span>`;
  // Render stance inline inside HP box
  let stanceEl = document.getElementById(prefix + '-stance');
  if (!stanceEl) {
    stanceEl = document.createElement('div');
    stanceEl.id = prefix + '-stance';
    stanceEl.className = 'stance-inline';
    document.querySelector('.hp-box.' + (who === 'player' ? 'player' : 'opponent')).appendChild(stanceEl);
  }
  if (b.stance) stanceEl.innerHTML = `<span class="stance-label">Stance:</span> <span class="stance-name-text">${b.stance.name}</span> <span class="stance-desc-text">— ${b.stance.desc}</span>`;
  else stanceEl.innerHTML = `<span class="stance-label">Stance:</span> <span style="color:#5a5040;font-style:italic">None</span>`;
  document.getElementById(prefix + '-types').innerHTML = '';
  updateHpBar(who);
}

function renderSprite(who) {
  const b = who === 'player' ? player() : opponent();
  const canvas = document.getElementById(who === 'player' ? 'player-sprite' : 'opp-sprite');
  canvas.classList.remove('fainted','hit','attacking','entering');
  drawSprite(canvas, b.cls.sprite, b.cls.color, who === 'player');
  canvas.classList.add('entering');
  setTimeout(() => canvas.classList.remove('entering'), 400);
}

function renderRoster(who) {
  const team = who === 'player' ? playerTeam : oppTeam;
  const activeIdx = who === 'player' ? playerActive : oppActive;
  const el = document.getElementById(who === 'player' ? 'player-roster' : 'opp-roster');
  el.innerHTML = '';
  // If active unit is a summon, show the owner in the roster as switchable
  const activeUnit = team[activeIdx];
  const summonOwner = activeUnit?.isSummon ? activeUnit.summonOwner : null;
  team.forEach((b, i) => {
    const entry = document.createElement('div');
    entry.className = 'roster-entry' + (i === activeIdx ? ' active' : '') + (b.fainted ? ' fainted' : '');
    if (who === 'player' && !b.fainted && i !== activeIdx && !isAnimating && !player()?.switchLocked) entry.classList.add('switchable');
    const pct = Math.max(0, b.currentHp / b.maxHp * 100);
    const barCls = pct < 25 ? 'red' : pct < 50 ? 'yellow' : '';
    const statusHtml = b.status ? `<div class="roster-status"><span class="status-effect-tag ${b.status}">${STATUS_ICONS[b.status]||''} ${b.status.toUpperCase()}</span></div>` : '';
    entry.innerHTML = `<div class="roster-name" style="color:${b.cls.color}">${b.name}</div>
      <div class="roster-class">${b.cls.label} ${b.fainted ? '(KO)' : Math.max(0,b.currentHp)+'/'+b.maxHp}</div>
      <div class="roster-hp-bar"><div class="roster-hp-fill ${barCls}" style="width:${pct}%"></div></div>${statusHtml}`;
    if (who === 'player' && !b.fainted && i !== activeIdx) {
      entry.onclick = () => { if (!isAnimating && !b.fainted) doSwitch(i); };
    }
    el.appendChild(entry);
  });
  // Show summon owner (Druid) as an extra switchable roster entry
  if (who === 'player' && summonOwner && !summonOwner.fainted) {
    const entry = document.createElement('div');
    entry.className = 'roster-entry switchable';
    const pct = Math.max(0, summonOwner.currentHp / summonOwner.maxHp * 100);
    const barCls = pct < 25 ? 'red' : pct < 50 ? 'yellow' : '';
    entry.innerHTML = `<div class="roster-name" style="color:${summonOwner.cls.color}">${summonOwner.name}</div>
      <div class="roster-class">${summonOwner.cls.label} ${Math.max(0,summonOwner.currentHp)}/${summonOwner.maxHp} (benched)</div>
      <div class="roster-hp-bar"><div class="roster-hp-fill ${barCls}" style="width:${pct}%"></div></div>`;
    entry.onclick = () => {
      if (!isAnimating) {
        // Kill the boar, restore Druid to slot, then switch to Druid
        activeUnit.currentHp = 0; activeUnit.fainted = true;
        log(`${activeUnit.name} is unsummoned and perishes!`, 'faint');
        team[activeIdx] = summonOwner;
        // "Switch" to the same slot (Druid is now there)
        clearEffectsOnSwitchOut(summonOwner); // clear any old effects
        removeStance(summonOwner);
        summonOwner.justSwitchedIn = true;
        log(`${summonOwner.name} returns to battle!`, 'switch');
        renderActiveInfo('player'); renderSprite('player'); renderRoster('player'); renderMoves();
        if (summonOwner.stances) {
          promptPlayerStance(summonOwner);
        }
      }
    };
    el.appendChild(entry);
  }
}

// ============================================================
//  TOOLTIP
// ============================================================
function calcMoveStats(ability, attacker) {
  const [count, sides] = ability.dice;
  const fixed = ability.fixed || 0;
  let minBase, maxBase, avgBase, atkStat, minDmg, maxDmg, avgDmg;
  if (ability.heal) {
    const statMod = mod(attacker.stats[ability.stat]);
    minBase = fixed + count + statMod;
    maxBase = fixed + count * sides + statMod;
    avgBase = fixed + count * (sides + 1) / 2 + statMod;
    atkStat = attacker.stats[ability.stat];
    minDmg = Math.max(1, minBase);
    maxDmg = maxBase;
    avgDmg = avgBase;
  } else {
    minBase = fixed + count;
    maxBase = fixed + count * sides;
    avgBase = fixed + count * (sides + 1) / 2;
    atkStat = ability.dmgType === 'physical' ? attacker.stats.atk : attacker.stats.int;
    // ATK/DEF multiplier range: ~0.5x to ~1.5x
    minDmg = Math.max(1, Math.floor(minBase * 0.5));
    maxDmg = Math.ceil(maxBase * 1.5);
    avgDmg = avgBase;
  }
  const variance = count * (sides * sides - 1) / 12;
  const stdDev = Math.sqrt(variance);
  const cv = avgBase > 0 ? stdDev / avgBase : 0;
  let varClass;
  if (cv < 0.22) { varClass = 'low'; }
  else if (cv < 0.35) { varClass = 'med'; }
  else if (cv < 0.48) { varClass = 'high'; }
  else { varClass = 'extreme'; }
  const varLabel = `σ ${stdDev.toFixed(1)}`;
  return { minDmg, maxDmg, avgDmg: avgDmg.toFixed(1), varLabel, varClass, stdDev, atkStat, fixed };
}

function showTooltip(btn, ability) {
  const p = player();
  const o = opponent();
  const s = calcMoveStats(ability, p);
  const fixed = ability.fixed || 0;
  const diceStr = fixed > 0 ? `${fixed}+${ability.dice[0]}d${ability.dice[1]}` : `${ability.dice[0]}d${ability.dice[1]}`;
  const typeLabel = TYPE_LABELS[ability.dmgType] || ability.dmgType;
  const typeIcon = TYPE_ICONS[ability.dmgType] || '';

  let effHtml = '';

  let rangeHtml = '';
  if (!ability.heal) {
    const rangePct = s.maxDmg > 0 ? ((s.avgDmg - s.minDmg) / (s.maxDmg - s.minDmg || 1)) * 100 : 50;
    rangeHtml = `<div class="tt-range-bar"><div class="tt-range-fill" style="width:100%"></div><div class="tt-range-avg" style="left:${rangePct}%"></div></div>
      <div class="tt-range-labels"><span>${s.minDmg} min</span><span>${s.avgDmg} avg</span><span>${s.maxDmg} max</span></div>`;
  }

  const drainNote = ability.drain ? `<div class="tt-stat"><span class="tt-stat-label">Special</span><span class="tt-stat-val">Heals ${ability.drain*100}% of damage</span></div>` : '';
  const effectNote = ability.effect ? `<div class="tt-stat"><span class="tt-stat-label">Effect</span><span class="tt-stat-val">May inflict ${ability.effect}</span></div>` : '';
  const freezeNote = ability.freezeChance ? `<div class="tt-stat"><span class="tt-stat-label">Freeze</span><span class="tt-stat-val">${ability.freezeChance*100}% chance</span></div>` : '';
  const frozenReq = ability.requiresFrozen ? `<div class="tt-stat"><span class="tt-stat-label">Requires</span><span class="tt-stat-val" style="color:#8ad">Target must be FROZEN</span></div>` : '';

  tooltipEl.innerHTML = `
    <div class="tt-name">${ability.name}</div>
    <span class="tt-type ${ability.dmgType}">${typeIcon} ${typeLabel}</span>
    <div class="tt-stats">
      <div class="tt-stat"><span class="tt-stat-label">Dice</span><span class="tt-stat-val">${diceStr}</span></div>
      <div class="tt-stat"><span class="tt-stat-label">${ability.heal ? 'Stat' : 'Scaling'}</span><span class="tt-stat-val">${ability.heal ? ability.stat.toUpperCase() : ability.dmgType === 'soul' ? 'None (raw dice)' : (ability.dmgType === 'physical' ? 'ATK vs DEF' : 'INT vs INT') + ' (' + (ability.dmgType === 'physical' ? 'ATK' : 'INT') + ': ' + s.atkStat + ')'}</span></div>
      <div class="tt-stat"><span class="tt-stat-label">Uses</span><span class="tt-stat-val">${ability.currentUses} / ${ability.uses}</span></div>
      ${drainNote}${effectNote}${freezeNote}${frozenReq}
    </div>
    ${ability.heal ? '' : `<div class="tt-variance ${s.varClass}">St.Dev: ${s.varLabel}</div>`}
    ${rangeHtml}
    ${effHtml}
    <div class="tt-desc">${ability.desc}</div>`;

  tooltipEl.style.display = 'block';
  const rect = btn.getBoundingClientRect();
  let top = rect.top - tooltipEl.offsetHeight - 8;
  if (top < 5) top = rect.bottom + 8;
  let left = rect.left + rect.width / 2 - 130;
  left = Math.max(5, Math.min(left, window.innerWidth - 270));
  tooltipEl.style.top = top + 'px';
  tooltipEl.style.left = left + 'px';
}

function hideTooltip() { tooltipEl.style.display = 'none'; }

// ============================================================
//  MOVE BUTTONS
// ============================================================
function renderMoves() {
  moveButtonsEl.innerHTML = '';
  const p = player();
  if (!p || p.fainted) return;
  p.abilities.forEach((ab, i) => {
    const btn = document.createElement('button');
    btn.className = 'move-btn';
    btn.dataset.dmg = ab.dmgType;
    const fixed = ab.fixed || 0;
    const diceStr = fixed > 0 ? `${fixed}+${ab.dice[0]}d${ab.dice[1]}` : `${ab.dice[0]}d${ab.dice[1]}`;
    const tag = ab.heal ? 'HEAL' : ab.dmgType.toUpperCase();
    let effHint = '';
    const scaleInfo = ab.heal ? ab.stat.toUpperCase() : (ab.dmgType === 'soul' ? '—' : ab.dmgType === 'physical' ? 'ATK' : 'INT');
    btn.innerHTML = `<span class="move-name">${ab.name}${effHint}</span><span class="move-info">${tag} | ${diceStr} | ${scaleInfo} | ${ab.currentUses}/${ab.uses}</span>`;
    btn.disabled = ab.currentUses <= 0 || isAnimating || (ab.requiresFrozen && (!opponent() || opponent().status !== 'frozen'))
      || (player().bladeTossCooldown && (ab.bladeToss || ab.recklessSwing));
    btn.onclick = () => executeTurn(i);
    btn.onmouseenter = () => showTooltip(btn, ab);
    btn.onmouseleave = hideTooltip;
    moveButtonsEl.appendChild(btn);
  });
}

// ============================================================
//  BATTLE FLOW
// ============================================================
// ============================================================
//  STANCES
// ============================================================
function applyStance(combatant, stance) {
  combatant.stance = stance;
  if (stance.statBoosts) {
    for (const [stat, val] of Object.entries(stance.statBoosts)) {
      combatant.stats[stat] += val;
    }
    // Recalc HP if CON boosted
    if (stance.statBoosts.con) {
      const newMax = calcHP(combatant.stats.con, combatant.level);
      const diff = newMax - combatant.maxHp;
      combatant.maxHp = newMax;
      combatant.currentHp += diff;
    }
  }
  // Check if enemy has Overwhelming stance (suppresses switch-in effects)
  const isPlayerSwitching = playerTeam.includes(combatant);
  const enemyActive = isPlayerSwitching ? opponent() : player();
  const overwhelmed = enemyActive?.stance?.passive === 'overwhelming';

  // Flashy Arrival: apply 2 blind stacks to opponent on stance selection
  if (stance.passive === 'flashyBlind') {
    const target = isPlayerSwitching ? opponent() : player();
    if (target && !target.fainted && !overwhelmed) {
      target.blindStacks += 2;
      log(`Flashy Arrival! ${target.name} is blinded! (${target.blindStacks} stacks, ${target.blindStacks*15}% miss)`, 'status');
      updateHpBar(!isPlayerSwitching ? 'player' : 'opponent');
    } else if (overwhelmed) {
      log(`Flashy Arrival suppressed by ${enemyActive.name}'s Overwhelming presence!`, 'status');
    }
  }
  // Guerilla Fighter: throw a 30% power Battlerang on switch-in
  if (stance.guerillaEntry && !overwhelmed) {
    const target = isPlayerSwitching ? opponent() : player();
    if (target && !target.fainted) {
      const baseFixed = ABILITIES.battlerang.fixed;
      const entryFixed = Math.max(1, Math.floor(baseFixed * 0.3));
      const entryDice = [1, 3]; // reduced dice too
      // Calculate damage using physical formula
      const atkStat = combatant.stats.atk;
      const defStat = target.stats.def;
      const baseDmg = entryFixed + Math.floor(Math.random() * entryDice[1]) + 1;
      const atkRoll = rollDice(2, 6) + atkStat;
      const defRoll = rollDice(2, 6) + defStat;
      const multiplier = 0.5 + 0.5 * (atkRoll / Math.max(1, defRoll));
      const dmg = Math.max(1, Math.round(baseDmg * multiplier));
      target.currentHp = Math.max(0, target.currentHp - dmg);
      target.damagedThisTurn = true;
      log(`Guerilla Fighter! ${combatant.name} throws a quick rang on entry for ${dmg} damage!`, 'damage');
      updateHpBar(!isPlayer ? 'player' : 'opponent');
      showDmgFloat(!isPlayer ? 'player' : 'opponent', dmg, false, false);
      renderRoster(!isPlayer ? 'player' : 'opponent');
      // Frozen thaw
      if (target.status === 'frozen') {
        target.status = null; target.statusTurns = 0;
        log(`  ${target.name} thaws from the impact!`, 'status');
        updateHpBar(!isPlayer ? 'player' : 'opponent');
      }
      if (target.currentHp <= 0 && !target.fainted) {
        target.fainted = true; animateFaint(target);
      }
    }
  }
  // Overgrowth: set vine terrain on switch-in
  if (stance.overgrowthEntry && !overwhelmed) {
    terrain = { name: 'Overgrowth Vines', turnsLeft: 5, effect: 'vineSqueze' };
    log(`Overgrowth! Vines sprout across the battlefield! (5 turns)`, 'status');
    document.getElementById('terrain-display').innerHTML = '| 🌿 Overgrowth Vines (5t)';
  } else if (stance.overgrowthEntry && overwhelmed) {
    log(`Overgrowth suppressed by ${enemyActive.name}'s Overwhelming presence!`, 'status');
  }
}

function removeStance(combatant) {
  if (!combatant.stance) return;
  if (combatant.stance.statBoosts) {
    for (const [stat, val] of Object.entries(combatant.stance.statBoosts)) {
      combatant.stats[stat] -= val;
    }
    if (combatant.stance.statBoosts.con) {
      combatant.maxHp = calcHP(combatant.stats.con, combatant.level);
      combatant.currentHp = Math.min(combatant.currentHp, combatant.maxHp);
    }
  }
  combatant.stance = null;
}

let stanceModalOpen = false;
function showStanceModal(combatant) {
  return new Promise(resolve => {
    if (stanceModalOpen) { resolve(aiPickStance(combatant)); return; }
    // Auto-apply for single-stance characters (e.g. Battle Boar)
    if (combatant.stances.length === 1) { resolve(combatant.stances[0]); return; }
    stanceModalOpen = true;
    const modal = document.getElementById('stance-modal');
    const box = document.getElementById('stance-box');
    box.innerHTML = `<h3>Choose stance for ${combatant.name} the ${combatant.cls.label}</h3>`;
    combatant.stances.forEach(stance => {
      const btn = document.createElement('button');
      btn.className = 'stance-btn';
      btn.innerHTML = `<div class="stance-name">${stance.name}</div><div class="stance-desc">${stance.desc}</div>`;
      btn.onclick = () => { modal.classList.remove('show'); stanceModalOpen = false; resolve(stance); };
      box.appendChild(btn);
    });
    modal.classList.add('show');
  });
}

function aiPickStance(combatant) {
  return pick(combatant.stances);
}

async function startBattle() {
  battleNum++;
  document.getElementById('battle-num').textContent = battleNum;

  const level = Math.min(20, 5 + Math.floor(battleNum / 3));
  const TESTING_1V1 = window.TESTING_1V1 = false; // Set to true for 1v1 testing
  const lichCls = CLASSES.find(c => c.id === 'lich');
  const pitDwellerCls = CLASSES.find(c => c.id === 'pitDweller');
  const sirShiningCls = CLASSES.find(c => c.id === 'sirShining');
  const rexRangCls = CLASSES.find(c => c.id === 'rexRang');
  const countCoctionCls = CLASSES.find(c => c.id === 'countCoction');
  const lexilasCls = CLASSES.find(c => c.id === 'lexilas');
  const vinyCls = CLASSES.find(c => c.id === 'viny');
  const jahCls = CLASSES.find(c => c.id === 'jahApostle');
  if (TESTING_1V1) {
    // 1v1 test mode: random matchup from custom characters
    const customs = [lichCls, pitDwellerCls, sirShiningCls, rexRangCls, countCoctionCls, lexilasCls, vinyCls, jahCls];
    const shuffled = shuffle(customs);
    playerTeam = [createCombatant(shuffled[0], level)];
    oppTeam = [createCombatant(shuffled[1], level)];
  } else {
    // 4v4 mode: 8 characters, 4 each
    const customs = shuffle([lichCls, pitDwellerCls, sirShiningCls, rexRangCls, countCoctionCls, lexilasCls, vinyCls, jahCls]);
    playerTeam = customs.slice(0, 4).map(c => createCombatant(c, level));
    oppTeam = customs.slice(4, 8).map(c => createCombatant(c, level));
  }
  playerActive = 0; oppActive = 0;
  terrain = null; // Reset terrain each battle
  window.ancientPowerQueue = []; // Reset delayed damage queue

  // Apply stances for AI team members with stances
  oppTeam.forEach(b => { if (b.stances) { applyStance(b, aiPickStance(b)); } });
  // Player team members get stance on switch-in (not pre-applied)

  renderActiveInfo('player'); renderActiveInfo('opponent');
  renderSprite('player'); renderSprite('opponent');
  renderRoster('player'); renderRoster('opponent');
  renderMoves();

  log(`--- Encounter #${battleNum} ---`, 'divider');
  log(`Your team: ${playerTeam.map(b => b.name + ' the ' + b.cls.label).join(', ')}`, 'info');
  log(`Enemy team: ${oppTeam.map(b => b.name + ' the ' + b.cls.label).join(', ')}`, 'info');
  const fmtStats = b => `ATK:${b.stats.atk} DEF:${b.stats.def} CON:${b.stats.con} INT:${b.stats.int} CHA:${b.stats.cha} SPD:${b.stats.spd}`;
  log(`${player().name} the ${player().cls.label} steps into the arena. [${fmtStats(player())}] HP:${player().maxHp}`, 'info');
  log(`${opponent().name} the ${opponent().cls.label} stands ready! [${fmtStats(opponent())}] HP:${opponent().maxHp}`, 'info');

  // Prompt stance for active player if they have stances
  if (player().stances && !player().stance) {
    await promptPlayerStance(player());
  }
}

async function promptPlayerStance(combatant) {
  if (autoMode) { applyStance(combatant, aiPickStance(combatant)); renderActiveInfo('player'); renderMoves(); return; }
  isAnimating = true;
  const stance = await showStanceModal(combatant);
  applyStance(combatant, stance);
  log(`${combatant.name} enters ${stance.name} stance! ${stance.desc}`, 'info');
  isAnimating = false;
  renderActiveInfo('player'); renderRoster('player'); renderMoves();
}

// Check if any teammate has a moonlight heal stored, apply to the switching-in unit
function applyMoonlightHeal(switchingIn, team, who) {
  for (const member of team) {
    if (member !== switchingIn && member.moonlightHeal && member.moonlightHeal > 0) {
      const heal = Math.min(member.moonlightHeal, switchingIn.maxHp - switchingIn.currentHp);
      if (heal > 0) {
        switchingIn.currentHp += heal;
        log(`Moonlight blesses ${switchingIn.name}! Healed ${heal} HP!`, 'heal');
        updateHpBar(who); renderRoster(who);
      }
      member.moonlightHeal = 0;
      break; // Only one moonlight heal per switch
    }
  }
}

function clearEffectsOnSwitchOut(unit) {
  // Restoration: heal on switch-out (before removing stance)
  if (unit.stance?.passive === 'restoration' && !unit.fainted && unit.currentHp > 0) {
    const heal = Math.floor(unit.maxHp * 0.20);
    unit.currentHp = Math.min(unit.maxHp, unit.currentHp + heal);
    log(`Restoration! ${unit.name} heals ${heal} HP on withdrawal!`, 'heal');
  }
  unit.deathLustTurns = 0;
  if (unit.whittleBoost) { unit.stats.atk -= unit.whittleBoost; unit.whittleBoost = 0; }
  if (unit.duelistStacks) { unit.stats.atk -= unit.duelistStacks; unit.duelistStacks = 0; }
  if (unit.woundedStacks > 0) { unit.woundedStacks--; log(`${unit.name} shakes off a wound on switch-out (${unit.woundedStacks} remaining).`, 'info'); }
  unit.swerveActive = false; unit.swerveLastTurn = false;
  unit.bladeTossCooldown = false;
  removeStance(unit);
}

async function doSwitch(newIdx) {
  if (isAnimating || playerTeam[newIdx].fainted) return;
  if (player().switchLocked) {
    log(`${player().name} is pinned and can't switch!`, 'status');
    return;
  }
  if (player().lookAtMeLocked) {
    log(`${player().name} is locked by Look at Me and can't switch!`, 'status');
    // Grant shield to opponent team
    const oppTeamMembers = oppTeam;
    let shieldTurns = 2;
    let shieldHp = 15;
    if (opponent().stance?.passive === 'healBoost') { shieldTurns = 3; shieldHp = 20; }
    for (const member of oppTeamMembers) {
      if (!member.fainted) { member.shieldTurns = Math.max(member.shieldTurns, shieldTurns); member.shieldHp = Math.max(member.shieldHp, shieldHp); }
    }
    log(`The opponent's team gains a ${shieldHp}HP shield for ${shieldTurns} turns!`, 'status');
    updateHpBar('player'); updateHpBar('opponent');
    renderRoster('player'); renderRoster('opponent');
    player().lookAtMeLocked = false;
    return;
  }
  isAnimating = true;
  try {
    const oldP = player();
    // Summons die when switched out
    if (oldP.isSummon) {
      oldP.currentHp = 0; oldP.fainted = true;
      log(`${oldP.name} is unsummoned and perishes!`, 'faint');
      // Restore the owner to this slot
      if (oldP.summonOwner) {
        playerTeam[playerActive] = oldP.summonOwner;
      }
    }
    clearEffectsOnSwitchOut(oldP);
    playerActive = newIdx;
    // Always clear stance on the incoming character so they get a fresh pick
    removeStance(player());
    player().justSwitchedIn = true;
    log(`${oldP.name} withdraws! ${player().name} the ${player().cls.label} enters the battle!`, 'switch');
    renderActiveInfo('player'); renderSprite('player'); renderRoster('player'); renderMoves();

    // Stance selection for new active
    if (player().stances) {
      if (autoMode) { applyStance(player(), aiPickStance(player())); }
      else {
        const stance = await showStanceModal(player());
        applyStance(player(), stance);
        log(`${player().name} enters ${stance.name} stance! ${stance.desc}`, 'info');
      }
      renderActiveInfo('player'); renderRoster('player'); renderMoves();
    }

    // Check if AI also wants to switch simultaneously
    const aiSwitchIdx = aiShouldSwitch();
    if (aiSwitchIdx !== null && !window.TESTING_1V1) {
      // Both sides switching — simultaneous! No free attacks.
      log(`${opponent().name} also withdraws!`, 'switch');
      clearEffectsOnSwitchOut(opponent());
      oppActive = aiSwitchIdx;
      opponent().justSwitchedIn = true;
      log(`${opponent().name} the ${opponent().cls.label} enters the battle!`, 'switch');
      renderActiveInfo('opponent'); renderSprite('opponent'); renderRoster('opponent');
      // AI picks stance (but don't apply effects yet)
      const aiStance = aiPickStance(opponent());
      // Apply both stances without switch-in effects first
      const playerStance = player().stance;
      const oppUnit = opponent();
      // Now apply AI stance (effects will check for Overwhelming)
      applyStance(oppUnit, aiStance);
      renderActiveInfo('opponent'); renderRoster('opponent');
      // Moonlight heals
      applyMoonlightHeal(player(), playerTeam, 'player');
      applyMoonlightHeal(opponent(), oppTeam, 'opponent');
      // Both switch — no free attacks, just tick
      await delay(1000);
      if (!player().fainted) await tickStatus(player());
      if (!opponent().fainted) await tickStatus(opponent());
    } else {
      // Only player switched — opponent gets free attack
      applyMoonlightHeal(player(), playerTeam, 'player');
      await delay(1000);
      const oppAbIdx = pickAIAbility();
      const oppAb = opponent().abilities[oppAbIdx]?.currentUses > 0 ? opponent().abilities[oppAbIdx] : STRUGGLE;
      await executeAbility(opponent(), player(), oppAb);
      if (player().fainted) { await handleFaint('player'); }
      if (!opponent().fainted) await tickStatus(opponent());
      if (!player().fainted) await tickStatus(player());
    }
  } finally {
    isAnimating = false;
  }
  renderMoves(); renderRoster('player'); renderRoster('opponent');
  if (checkWin()) return;
  if (autoMode) scheduleAutoTurn();
}

const STRUGGLE = { name:'Desperate Strike', dmgType:'physical', stat:'atk', dice:[1,4], bonus:0, acc:0, uses:999, currentUses:999, desc:'A feeble last resort' };

async function executeTurn(moveIdx) {
  if (isAnimating) return;
  isAnimating = true;
  hideTooltip();
  try {
    const p = player(), o = opponent();
    const playerAb = p.abilities[moveIdx]?.currentUses > 0 ? p.abilities[moveIdx] : STRUGGLE;

    // AI switch decision (made simultaneously with player's move choice)
    const aiSwitchIdx = aiShouldSwitch();
    if (aiSwitchIdx !== null && !window.TESTING_1V1) {
      // AI switches out — player gets a free attack on the incoming unit
      log(`${o.name} withdraws!`, 'switch');
      clearEffectsOnSwitchOut(o);
      oppActive = aiSwitchIdx;
      const newOpp = opponent();
      newOpp.justSwitchedIn = true;
      log(`${newOpp.name} the ${newOpp.cls.label} enters the battle!`, 'switch');
      renderActiveInfo('opponent'); renderSprite('opponent'); renderRoster('opponent');
      // Pick and apply stance
      applyStance(newOpp, aiPickStance(newOpp));
      renderActiveInfo('opponent'); renderRoster('opponent');
      // Flashy Arrival handled by applyStance above (includes Overwhelming check)
      // Moonlight heal on switch-in
      applyMoonlightHeal(newOpp, oppTeam, 'opponent');
      // Player gets free attack
      await delay(1000);
      await executeAbility(p, opponent(), playerAb);
      if (opponent().fainted) { await handleFaint('opponent'); }
      if (!p.fainted) await tickStatus(p);
      if (!opponent().fainted) await tickStatus(opponent());
      isAnimating = false;
      renderMoves(); renderRoster('player'); renderRoster('opponent');
      if (checkWin()) return;
      if (autoMode) scheduleAutoTurn();
      return;
    }

    const oppAbIdx = pickAIAbility();
    const oppAb = o.abilities[oppAbIdx]?.currentUses > 0 ? o.abilities[oppAbIdx] : STRUGGLE;

    // Reset per-turn state
    p.damagedThisTurn = false;
    o.damagedThisTurn = false;
    p.justSwitchedIn = false;
    o.justSwitchedIn = false;

    // Overwhelming stance: suppress enemy passive (store and null it)
    let pSuppressedPassive = null, oSuppressedPassive = null;
    if (p.stance?.passive === 'overwhelming' && o.stance) {
      pSuppressedPassive = o.stance.passive; o.stance = {...o.stance, passive: null};
    }
    if (o.stance?.passive === 'overwhelming' && p.stance) {
      oSuppressedPassive = p.stance.passive; p.stance = {...p.stance, passive: null};
    }

    // Speed modifiers
    let pInit = getInitiative(p);
    let oInit = getInitiative(o);
    if (playerAb.counterMove) pInit = Math.floor(pInit * 0.5);
    if (oppAb.counterMove) oInit = Math.floor(oInit * 0.5);
    if (playerAb.makeWay) pInit = Math.floor(pInit * 2.0); // massive speed boost
    if (oppAb.makeWay) oInit = Math.floor(oInit * 2.0);
    if (playerAb.swerve) pInit = Math.floor(pInit * 1.5); // Swerve: act fast
    if (oppAb.swerve) oInit = Math.floor(oInit * 1.5);
    // Blade Toss: increased SPD this turn
    if (playerAb.bladeToss) pInit = Math.floor(pInit * 1.5);
    if (oppAb.bladeToss) oInit = Math.floor(oInit * 1.5);
    // Chivalry: greatly reduced priority (always goes last)
    if (playerAb.chivalry) pInit = -100;
    if (oppAb.chivalry) oInit = -100;
    // Battle Boar: reduced priority (Druid tanks a hit before summoning)
    if (playerAb.reducedPriority) pInit = -50;
    if (oppAb.reducedPriority) oInit = -50;
    // Shield Bash: +DEF, -SPD for the turn
    if (playerAb.shieldBash) { p.shieldBashDef = 4; p.shieldBashSpd = Math.floor(p.stats.spd * 0.4); p.stats.def += 4; p.stats.spd -= p.shieldBashSpd; p.shieldBashActive = true; }
    if (oppAb.shieldBash) { o.shieldBashDef = 4; o.shieldBashSpd = Math.floor(o.stats.spd * 0.4); o.stats.def += 4; o.stats.spd -= o.shieldBashSpd; o.shieldBashActive = true; }
    // Make Way: DEF bonus for this turn
    if (playerAb.makeWay) { p.defBonusThisTurn = 5; p.stats.def += 5; }
    if (oppAb.makeWay) { o.defBonusThisTurn = 5; o.stats.def += 5; }
    // Swerve: set dodge active
    if (playerAb.swerve) { p.swerveActive = !p.swerveLastTurn ? 'high' : 'low'; }
    if (oppAb.swerve) { o.swerveActive = !o.swerveLastTurn ? 'high' : 'low'; }

    let first, second, firstAb, secondAb;
    if (pInit >= oInit) { first = p; second = o; firstAb = playerAb; secondAb = oppAb; }
    else { first = o; second = p; firstAb = oppAb; secondAb = playerAb; }
    log(`Initiative: ${p.name} ${pInit} vs ${o.name} ${oInit}`, 'roll');

    await executeAbility(first, second, firstAb);
    if (second.fainted) await handleFaint(second === p ? 'player' : 'opponent');
    if (first.fainted) await handleFaint(first === p ? 'player' : 'opponent');

    if (checkWin()) return;

    if (!second.fainted && !first.fainted) {
      if (second.flinched) {
        log(`${second.name} flinched and can't move!`, 'status');
      } else {
        await delay(800);
        await executeAbility(second, first, secondAb);
        if (first.fainted) await handleFaint(first === p ? 'player' : 'opponent');
        if (second.fainted) await handleFaint(second === p ? 'player' : 'opponent');
      }
    }

    if (checkWin()) return;

    // Resolve Chivalry: heals if Warrior didn't take damage this turn
    for (const fighter of [p, o]) {
      if (fighter.chivalryPending && !fighter.fainted) {
        if (!fighter.damagedThisTurn) {
          const healAmt = Math.max(10, Math.round(fighter.maxHp * 0.30));
          fighter.currentHp = Math.min(fighter.maxHp, fighter.currentHp + healAmt);
          const side = playerTeam.includes(fighter) ? 'player' : 'opponent';
          updateHpBar(side);
          showDmgFloat(side, healAmt, false, true);
          log(`${fighter.name}'s Chivalry pays off! Untouched — healed ${healAmt} HP!`, 'heal');
        } else {
          log(`${fighter.name}'s Chivalry fails — took damage this turn.`, 'info');
        }
        fighter.chivalryPending = false;
      }
    }

    if (!player().fainted) await tickStatus(player());
    if (!opponent().fainted) await tickStatus(opponent());
    if (player().fainted) await handleFaint('player');
    if (opponent().fainted) await handleFaint('opponent');

    if (checkWin()) return;

    // Restore suppressed passives
    if (pSuppressedPassive && o.stance) o.stance = {...o.stance, passive: pSuppressedPassive};
    if (oSuppressedPassive && p.stance) p.stance = {...p.stance, passive: oSuppressedPassive};

    // Restore Make Way DEF bonus
    if (p.defBonusThisTurn) { p.stats.def -= p.defBonusThisTurn; p.defBonusThisTurn = 0; }
    if (o.defBonusThisTurn) { o.stats.def -= o.defBonusThisTurn; o.defBonusThisTurn = 0; }
    // Restore Shield Bash DEF/SPD
    if (p.shieldBashActive) { p.stats.def -= p.shieldBashDef; p.stats.spd += p.shieldBashSpd; p.shieldBashActive = false; }
    if (o.shieldBashActive) { o.stats.def -= o.shieldBashDef; o.stats.spd += o.shieldBashSpd; o.shieldBashActive = false; }
    // Blade Toss cooldown: can't use Reckless Swing or Blade Toss next turn
    for (const fighter of [p, o]) {
      if (fighter.bladeTossCooldown) { fighter.bladeTossCooldown = false; } // clear last turn's cooldown
    }
    if (playerAb.bladeToss) p.bladeTossCooldown = true;
    if (oppAb.bladeToss) o.bladeTossCooldown = true;

    // (Healing Prayer is now instant — no pending heal logic needed)

    // Ancient Power: resolve delayed hits
    if (window.ancientPowerQueue && window.ancientPowerQueue.length > 0) {
      for (let i = window.ancientPowerQueue.length - 1; i >= 0; i--) {
        const ap = window.ancientPowerQueue[i];
        ap.turnsLeft--;
        if (ap.turnsLeft <= 0) {
          window.ancientPowerQueue.splice(i, 1);
          const target = ap.defender;
          const caster = ap.attacker;
          if (!target.fainted && target.currentHp > 0 && !caster.fainted) {
            const ability = ABILITIES.ancientPower;
            const baseDmg = ability.fixed + rollDice(ability.dice[0], ability.dice[1]);
            const atkRoll = rollDice(2, 6) + caster.stats.int;
            const defRoll = rollDice(2, 6) + target.stats.int;
            const mult = 0.5 + 0.5 * (atkRoll / Math.max(1, defRoll));
            const dmg = Math.max(1, Math.round(baseDmg * mult));
            target.currentHp = Math.max(0, target.currentHp - dmg);
            target.damagedThisTurn = true;
            const targetSide = playerTeam.includes(target) ? 'player' : 'opponent';
            showDmgFloat(targetSide, dmg, dmg > 25, false);
            log(`Ancient Power strikes ${target.name} for ${dmg} magic damage!`, 'damage');
            updateHpBar(targetSide);
            if (target.currentHp <= 0 && !target.fainted) { target.fainted = true; animateFaint(target); }
          } else if (caster.fainted) {
            log(`Ancient Power fizzles — ${caster.name} has fallen.`, 'info');
          }
        }
      }
      if (checkWin()) return;
    }

    // Terrain tick
    if (terrain && terrain.turnsLeft > 0) {
      terrain.turnsLeft--;
      // Vine terrain: squeeze the first mover for fixed damage
      if (terrain.effect === 'vineSqueze') {
        const firstMover = first;
        const firstSide = (first === p) ? 'player' : 'opponent';
        if (!firstMover.fainted && firstMover.currentHp > 0) {
          const vineDmg = 4;
          firstMover.currentHp = Math.max(0, firstMover.currentHp - vineDmg);
          firstMover.damagedThisTurn = true;
          log(`Vines squeeze ${firstMover.name} for ${vineDmg} damage!`, 'damage');
          showDmgFloat(firstSide, vineDmg, false, false);
          updateHpBar(firstSide);
          if (firstMover.currentHp <= 0 && !firstMover.fainted) { firstMover.fainted = true; animateFaint(firstMover); }
        }
      }
      if (terrain.effect === 'poisonBoth') {
        for (const fighter of [player(), opponent()]) {
          if (!fighter.fainted && fighter.currentHp > 0) {
            const isFighterPlayer = playerTeam.includes(fighter);
            const enemy = isFighterPlayer ? opponent() : player();
            let stacks = 1;
            // Rapid Transmission: check if the ENEMY has this passive (since they're the poisoner)
            if (enemy.stance?.passive === 'rapidTransmission') {
              const rtChance = 0.30 + Math.max(0, (enemy.stats.cha - fighter.stats.cha)) * 0.02;
              if (Math.random() < rtChance) { stacks += 1; log(`  Rapid Transmission! Extra poison on ${fighter.name}!`, 'status'); }
            }
            fighter.poisonStacks += stacks;
            log(`Goblin Gas poisons ${fighter.name}! (${fighter.poisonStacks} stack${fighter.poisonStacks>1?'s':''})`, 'status');
            updateHpBar(isFighterPlayer ? 'player' : 'opponent');
          }
        }
      }
      if (terrain.turnsLeft <= 0) {
        log(`The ${terrain.name} dissipates.`, 'info');
        terrain = null;
        document.getElementById('terrain-display').innerHTML = '';
      } else {
        const terrainIcon = terrain.effect === 'vineSqueze' ? '🌿' : '☁️';
        document.getElementById('terrain-display').innerHTML = `| ${terrainIcon} ${terrain.name} (${terrain.turnsLeft}t)`;
      }
    }

    // Make Way / Guerilla Fighter: auto-switch at end of turn
    async function autoSwitchOut(unit, team, activeIdx, side, reason) {
      const alive = team.filter((t,i) => i !== activeIdx && !t.fainted);
      if (alive.length === 0) return activeIdx;
      log(`${unit.name} ${reason}`, 'switch');
      clearEffectsOnSwitchOut(unit);
      unit.makeWaySwitch = false;
      let newIdx;
      if (side === 'player' && !autoMode && alive.length > 1) {
        newIdx = await showDeathSelectionModal(team, activeIdx);
      } else {
        newIdx = team.indexOf(alive[0]);
      }
      if (side === 'player') playerActive = newIdx; else oppActive = newIdx;
      const next = side === 'player' ? player() : opponent();
      next.justSwitchedIn = true;
      log(`${next.name} the ${next.cls.label} enters the battle!`, 'switch');
      renderActiveInfo(side); renderSprite(side); renderRoster(side);
      if (next.stances) {
        if (autoMode || side === 'opponent') { applyStance(next, aiPickStance(next)); }
        else {
          const stance = await showStanceModal(next);
          applyStance(next, stance);
          log(`${next.name} enters ${stance.name} stance! ${stance.desc}`, 'info');
        }
        renderActiveInfo(side); renderRoster(side);
      }
      if (side === 'player') renderMoves();
      // Moonlight heal on switch-in
      const switchTeam = side === 'player' ? playerTeam : oppTeam;
      applyMoonlightHeal(next, switchTeam, side);
      return newIdx;
    }

    if (!p.fainted && (playerAb.makeWay || p.makeWaySwitch) && playerTeam.length > 1) {
      await autoSwitchOut(p, playerTeam, playerActive, 'player',
        playerAb.makeWay ? 'charges through and withdraws!' : 'uses the opening to escape!');
    }
    if (!o.fainted && (oppAb.makeWay || o.makeWaySwitch) && oppTeam.length > 1) {
      await autoSwitchOut(o, oppTeam, oppActive, 'opponent',
        oppAb.makeWay ? 'charges through and withdraws!' : 'uses the opening to escape!');
    }

    if (checkWin()) return;
  } finally {
    isAnimating = false;
  }
  renderMoves(); renderRoster('player'); renderRoster('opponent');
  if (autoMode) scheduleAutoTurn();
}

async function executeAbility(attacker, defender, ability) {
  const atkName = attacker.name, defName = defender.name;
  const isPlayer = playerTeam.includes(attacker);

  // Stun: halves SPD/ATK/INT/CHA for this turn, then clears at end
  let stunDebuffs = null;
  if (attacker.status === 'stun') {
    stunDebuffs = {};
    for (const stat of ['spd','atk','int','cha']) {
      const reduction = Math.floor(attacker.stats[stat] / 2);
      stunDebuffs[stat] = reduction;
      attacker.stats[stat] -= reduction;
    }
    log(`${atkName} is stunned! SPD, ATK, INT, CHA halved this turn.`, 'status');
    attacker.statusTurns--;
    if (attacker.statusTurns <= 0) { attacker.status = null; }
  }
  if (attacker.status === 'frozen') {
    // Healing Prayer and Transference bypass frozen inaction
    if (ability.healingPrayer || ability.transference) {
      log(`${atkName} wills through the ice!`, 'status');
    } else {
      const roll = Math.random();
      if (roll < 0.333) {
        attacker.status = null; attacker.statusTurns = 0;
        log(`${atkName} thaws out and acts!`, 'status');
        updateHpBar(isPlayer ? 'player' : 'opponent');
      } else {
        log(`${atkName} is frozen solid and can't move!`, 'status');
        return;
      }
    }
  }
  if (attacker.status === 'slow' && Math.random() < 0.33) {
    log(`${atkName} is slowed and fumbles!`, 'status'); return;
  }

  ability.currentUses = Math.max(0, ability.currentUses - 1);

  // Shatter requires frozen target
  if (ability.requiresFrozen && defender.status !== 'frozen') {
    log(`${atkName} tries ${ability.name}, but ${defName} isn't frozen! The attack fails!`, 'miss');
    return;
  }

  if (ability.heal) {
    if (ability.healingPrayer) {
      const healAmt = Math.max(5, Math.floor(attacker.maxHp * 0.25));
      attacker.currentHp = Math.min(attacker.maxHp, attacker.currentHp + healAmt);
      attacker.status = null; attacker.statusTurns = 0; attacker.blindStacks = 0; attacker.burnStacks = 0; attacker.poisonStacks = 0; attacker.woundedStacks = 0; attacker.curseStacks = 0;
      updateHpBar(isPlayer ? 'player' : 'opponent');
      showDmgFloat(isPlayer ? 'player' : 'opponent', healAmt, false, true);
      log(`${atkName} uses Healing Prayer! Healed ${healAmt} HP and cured all statuses!`, 'heal');
      renderRoster(isPlayer ? 'player' : 'opponent');
      return;
    }
    const heal = rollHealForAbility(attacker, ability);
    attacker.currentHp = Math.min(attacker.maxHp, attacker.currentHp + heal);
    updateHpBar(isPlayer ? 'player' : 'opponent');
    showDmgFloat(isPlayer ? 'player' : 'opponent', heal, false, true);
    log(`${atkName} uses ${ability.name} and heals ${heal} HP!`, 'heal');
    renderRoster(isPlayer ? 'player' : 'opponent');
    return;
  }

  // Death Lust: grant buff (self-buff move, also deals light damage)
  if (ability.grantDeathLust) {
    attacker.deathLustTurns = 2;
    log(`${atkName} enters Death Lust! +4 soul damage per hit for 2 turns.`, 'status');
  }

  // Whittle: grant ATK boost until switch out
  if (ability.grantWhittle) {
    attacker.whittleBoost += 4;
    attacker.stats.atk += 4;
    log(`${atkName} sharpens up! +4 ATK (total +${attacker.whittleBoost} from Whittle).`, 'status');
    updateHpBar(isPlayer ? 'player' : 'opponent');
    renderActiveInfo(isPlayer ? 'player' : 'opponent');
    return;
  }

  // Swerve: no damage, just the dodge (already set up in executeTurn)
  if (ability.swerve) {
    log(`${atkName} swerves${attacker.swerveActive === 'high' ? '! 100% evasion this turn' : ' again — only 20% evasion'}.`, 'status');
    updateHpBar(isPlayer ? 'player' : 'opponent');
    return;
  }

  // Goblin Gas: set terrain effect
  if (ability.goblinGas) {
    terrain = { name: 'Goblin Gas', turnsLeft: 5, effect: 'poisonBoth' };
    log(`${atkName} deploys Goblin Gas! Both fighters will gain poison each turn for 5 turns!`, 'status');
    document.getElementById('terrain-display').innerHTML = '| ☁️ Goblin Gas (5t)';
    updateHpBar('player'); updateHpBar('opponent');
    return;
  }

  // Ancient Power: queue delayed magic damage (2 turns later)
  if (ability.ancientPower) {
    // Store pending ancient power hit
    if (!window.ancientPowerQueue) window.ancientPowerQueue = [];
    window.ancientPowerQueue.push({ turnsLeft: 2, attacker, defender, isPlayer });
    log(`${atkName} channels Ancient Power... It will strike in 2 turns!`, 'status');
    updateHpBar(isPlayer ? 'player' : 'opponent');
    return;
  }

  // Transference: transfer all status effects to enemy (ignores frozen inaction)
  if (ability.transference) {
    let transferred = false;
    // Transfer status (frozen/stun/poison)
    if (attacker.status) {
      defender.status = attacker.status;
      defender.statusTurns = attacker.statusTurns;
      attacker.status = null; attacker.statusTurns = 0;
      log(`${atkName} transfers ${defender.status} to ${defName}!`, 'status');
      transferred = true;
    }
    if (attacker.poisonStacks > 0) {
      defender.poisonStacks += attacker.poisonStacks;
      log(`${atkName} transfers ${attacker.poisonStacks} poison stacks to ${defName}! (${defender.poisonStacks} total)`, 'status');
      attacker.poisonStacks = 0;
      transferred = true;
    }
    if (attacker.burnStacks > 0) {
      defender.burnStacks += attacker.burnStacks;
      log(`${atkName} transfers ${attacker.burnStacks} burn stacks to ${defName}!`, 'status');
      attacker.burnStacks = 0;
      transferred = true;
    }
    if (attacker.blindStacks > 0) {
      defender.blindStacks += attacker.blindStacks;
      log(`${atkName} transfers ${attacker.blindStacks} blind stacks to ${defName}!`, 'status');
      attacker.blindStacks = 0;
      transferred = true;
    }
    if (attacker.curseStacks > 0) {
      defender.curseStacks += attacker.curseStacks;
      log(`${atkName} transfers ${attacker.curseStacks} curse stacks to ${defName}!`, 'status');
      attacker.curseStacks = 0;
      transferred = true;
    }
    if (attacker.woundedStacks > 0) {
      defender.woundedStacks += attacker.woundedStacks;
      log(`${atkName} transfers ${attacker.woundedStacks} wounded stacks to ${defName}!`, 'status');
      attacker.woundedStacks = 0;
      transferred = true;
    }
    if (!transferred) {
      log(`${atkName} tries Transference, but has no status effects to transfer!`, 'info');
    }
    updateHpBar('player'); updateHpBar('opponent');
    renderRoster('player'); renderRoster('opponent');
    return;
  }

  // Battle Boar: summon a boar to replace Druid
  if (ability.summonBoar) {
    const boarCls = CLASSES.find(c => c.id === 'battleBoar');
    const boar = createCombatant(boarCls, attacker.level);
    boar.summonOwner = attacker;
    boar.isSummon = true;
    // Replace attacker in team with boar
    const team = isPlayer ? playerTeam : oppTeam;
    const activeIdx = isPlayer ? playerActive : oppActive;
    clearEffectsOnSwitchOut(attacker);
    team[activeIdx] = boar;
    // Auto-apply Prickly stance
    applyStance(boar, boar.stances[0]);
    log(`${atkName} summons a Battle Boar and withdraws!`, 'switch');
    log(`Battle Boar enters with Prickly stance! Enemies take 1 damage when attacking.`, 'info');
    renderActiveInfo(isPlayer ? 'player' : 'opponent');
    renderSprite(isPlayer ? 'player' : 'opponent');
    renderRoster(isPlayer ? 'player' : 'opponent');
    if (isPlayer) renderMoves();
    return;
  }

  // Moonlight: heal self for decent amount + mark next ally to switch in for heal
  if (ability.moonlight) {
    let baseHeal = Math.max(8, Math.floor(attacker.maxHp * 0.25));
    if (attacker.stance?.passive === 'healBoost') baseHeal = Math.floor(baseHeal * 1.3);
    const selfHeal = Math.min(baseHeal, attacker.maxHp - attacker.currentHp);
    attacker.currentHp += selfHeal;
    // Mark: next ally to switch in gets healed
    attacker.moonlightHeal = baseHeal;
    log(`${atkName} channels moonlight! Healed self for ${selfHeal} HP. Next ally to enter will also be healed!`, 'heal');
    updateHpBar(isPlayer ? 'player' : 'opponent');
    renderRoster(isPlayer ? 'player' : 'opponent');
    return;
  }

  // Read Scripture: medium soul damage + variable curse stacks
  if (ability.readScripture) {
    // Determine curse stacks: 50% none, 25% one, 15% two, 10% three
    const roll = Math.random();
    let curseStacks = 0;
    if (roll < 0.10) curseStacks = 3;
    else if (roll < 0.25) curseStacks = 2;
    else if (roll < 0.50) curseStacks = 1;
    if (curseStacks > 0) {
      defender.curseStacks += curseStacks;
      log(`${atkName}'s scripture curses ${defName}! (+${curseStacks} curse stack${curseStacks>1?'s':''}, total ${defender.curseStacks})`, 'status');
      updateHpBar(!isPlayer ? 'player' : 'opponent');
    }
    // Fall through to normal hit for damage
  }

  // Riot: low soul damage + 2 curse stacks + 1 burn stack
  if (ability.riot) {
    defender.curseStacks += 2;
    defender.burnStacks += 1;
    log(`${atkName} incites a riot! ${defName} gains 2 curse stacks and 1 burn stack!`, 'status');
    updateHpBar(!isPlayer ? 'player' : 'opponent');
    // Fall through to normal hit for damage
  }

  // Look at Me: prevent switching + shield on attempt
  if (ability.lookAtMe) {
    defender.lookAtMeLocked = true;
    log(`${atkName}: "Look at me!" ${defName} can't switch this turn!`, 'status');
    updateHpBar(!isPlayer ? 'player' : 'opponent');
    return;
  }

  // Remedial Ointment: remove self poison and heal
  if (ability.remedialOintment) {
    const stacks = attacker.poisonStacks;
    if (stacks > 0) {
      const healAmt = stacks * 9;
      attacker.poisonStacks = 0;
      // Remove neurotoxin INT debuff
      if (defender.stance?.passive === 'neurotoxin') {
        // INT was already reduced — it'll be recalculated naturally since stacks are 0
      }
      attacker.currentHp = Math.min(attacker.maxHp, attacker.currentHp + healAmt);
      updateHpBar(isPlayer ? 'player' : 'opponent');
      showDmgFloat(isPlayer ? 'player' : 'opponent', healAmt, false, true);
      log(`${atkName} applies Remedial Ointment! Removed ${stacks} poison stacks and healed ${healAmt} HP!`, 'heal');
    } else {
      log(`${atkName} applies Remedial Ointment, but has no poison to remove!`, 'info');
    }
    renderRoster(isPlayer ? 'player' : 'opponent');
    return;
  }

  // Violent Extraction: remove enemy poison and deal soul damage per stack
  if (ability.violentExtraction) {
    const stacks = defender.poisonStacks;
    if (stacks > 0) {
      const dmg = stacks * 15;
      defender.poisonStacks = 0;
      defender.currentHp = Math.max(0, defender.currentHp - dmg);
      defender.damagedThisTurn = true;
      updateHpBar(!isPlayer ? 'player' : 'opponent');
      showDmgFloat(!isPlayer ? 'player' : 'opponent', dmg, stacks >= 4, false);
      log(`${atkName} violently extracts ${stacks} poison stacks from ${defName} for ${dmg} soul damage!`, 'damage');
      renderRoster(!isPlayer ? 'player' : 'opponent');
      if (defender.currentHp <= 0 && !defender.fainted) { defender.fainted = true; animateFaint(defender); }
    } else {
      log(`${atkName} tries Violent Extraction, but ${defName} has no poison!`, 'miss');
    }
    return;
  }

  // Chivalry: heals 30% max HP if Warrior didn't take damage this turn. Moves last.
  if (ability.chivalry) {
    attacker.chivalryPending = true;
    log(`${atkName} stands with honour...`, 'info');
    renderRoster(isPlayer ? 'player' : 'opponent');
    return;
  }

  log(`${atkName} uses ${ability.name}!`);
  const atkSprite = document.getElementById(isPlayer ? 'player-sprite' : 'opp-sprite');
  const defSprite = document.getElementById(isPlayer ? 'opp-sprite' : 'player-sprite');

  // Helper: deal a single hit
  async function dealHit(hitAbility, label) {
    // Blind miss check: each stack = 15% miss chance
    if (attacker.blindStacks > 0) {
      const missChance = attacker.blindStacks * 0.15;
      if (Math.random() < missChance) {
        attacker.blindStacks--;
        atkSprite.classList.add('attacking'); await delay(1000); atkSprite.classList.remove('attacking');
        log(`  ${label ? label + ': ' : ''}${atkName} misses through the blind! (${attacker.blindStacks} stacks left)`, 'miss');
        updateHpBar(isPlayer ? 'player' : 'opponent');
        return 0;
      }
    }

    // Swerve dodge check: defender dodges if swerving
    if (defender.swerveActive && !hitAbility.heal && !hitAbility.swerve && !hitAbility.grantWhittle) {
      const dodgeChance = defender.swerveActive === 'high' ? 1.0 : 0.2;
      if (Math.random() < dodgeChance) {
        atkSprite.classList.add('attacking'); await delay(1000); atkSprite.classList.remove('attacking');
        log(`  ${label ? label + ': ' : ''}${defName} swerves out of the way!`, 'miss');
        // Guerilla Fighter: switch out on dodge
        if (defender.stance?.passive === 'guerillaSwitchOut' && !window.TESTING_1V1) {
          defender.makeWaySwitch = true;
        }
        return 0;
      }
    }

    atkSprite.classList.add('attacking'); await delay(1000); atkSprite.classList.remove('attacking');
    defSprite.classList.add('hit'); await delay(500); defSprite.classList.remove('hit');

    let result, dmg;
    if (hitAbility.splitDamage) {
      // Heavenly Blow: half physical (ATK vs DEF), half magical (INT vs INT)
      const physResult = rollDamageForAbility(attacker, defender, {...hitAbility, dmgType:'physical'});
      const magResult = rollDamageForAbility(attacker, defender, {...hitAbility, dmgType:'magical', fixed:0, dice:[1,1]});
      const physHalf = Math.floor(physResult.damage / 2);
      const magHalf = Math.floor(magResult.damage / 2);
      dmg = Math.max(1, physHalf + magHalf);
      result = {damage: dmg, baseDmg: physResult.baseDmg, multiplier: 1.0};
      log(`  Split damage: ${physHalf} physical + ${magHalf} magical`, 'roll');
    } else {
      result = rollDamageForAbility(attacker, defender, hitAbility);
      dmg = result.damage;
    }

    // Counter Throw: bonus damage if opponent already hit you this turn
    if (hitAbility.counterMove && attacker.damagedThisTurn) {
      const bonus = Math.floor(dmg * 0.75);
      dmg += bonus;
      log(`  ${label ? label + ' — ' : ''}Counter! +${bonus} bonus damage (75%)!`, 'crit');
    }

    if (hitAbility.dmgType === 'soul') {
      log(`  ${label ? label + ': ' : ''}Base: ${result.baseDmg} (soul — no scaling)`, 'roll');
      showDiceFloat(isPlayer ? 'opponent' : 'player', `🎲 ${result.baseDmg} soul`);
    } else {
      const statLabel = hitAbility.dmgType === 'physical' ? 'ATK' : 'INT';
      const defLabel = hitAbility.dmgType === 'physical' ? 'DEF' : 'INT';
      log(`  ${label ? label + ': ' : ''}Base: ${result.baseDmg}, Roll: 2d6+${statLabel}=${result.atkRoll} vs 2d6+${defLabel}=${result.defRoll} (×${result.multiplier.toFixed(2)})`, 'roll');
      showDiceFloat(isPlayer ? 'player' : 'opponent', `🎲 ${result.atkRoll} vs ${result.defRoll} → ×${result.multiplier.toFixed(2)}`);
    }

    // Death Lust: bonus soul damage on attacks
    if (attacker.deathLustTurns > 0 && !hitAbility.heal && !hitAbility.grantDeathLust) {
      const soulBonus = 4;
      dmg += soulBonus;
      log(`  Death Lust! +${soulBonus} soul damage!`, 'status');
    }

    // Current HP % bonus (Shatter)
    if (hitAbility.currentHpPct && defender.currentHp > 0) {
      const hpBonus = Math.floor(defender.currentHp * hitAbility.currentHpPct);
      dmg += hpBonus;
      log(`  Shatter! +${hpBonus} bonus damage (${Math.round(hitAbility.currentHpPct*100)}% of current HP)!`, 'damage');
    }

    // Frozen target thaws on taking damage (no damage reduction)
    if (defender.status === 'frozen' && !hitAbility.requiresFrozen) {
      defender.status = null; defender.statusTurns = 0;
      log(`  ${defName} thaws from the impact!`, 'status');
      updateHpBar(!isPlayer ? 'player' : 'opponent');
    }

    // Crit: d100 + ATK > 100 = 1.5x damage
    let isCrit = false;
    if (dmg > 0 && !hitAbility.heal) {
      const critRoll = Math.floor(Math.random() * 100) + 1 + attacker.stats.atk;
      if (critRoll > 100) { dmg = Math.round(dmg * 1.5); isCrit = true; log(`  💥 CRITICAL HIT!`, 'damage'); }
    }

    const isBigHit = result.multiplier >= 1.2 || isCrit;

    // Shield: full block up to shieldHp, excess goes through
    if (defender.shieldTurns > 0 && defender.shieldHp > 0 && dmg > 0 && !hitAbility.heal) {
      const absorbed = Math.min(dmg, defender.shieldHp);
      defender.shieldHp -= absorbed;
      dmg -= absorbed;
      if (defender.shieldHp <= 0) { defender.shieldTurns = 0; log(`  ${defName}'s shield shatters after absorbing ${absorbed} damage!`, 'status'); }
      else { log(`  ${defName}'s shield absorbs ${absorbed} damage! (${defender.shieldHp} HP left)`, 'status'); }
      updateHpBar(!isPlayer ? 'player' : 'opponent');
    }

    defender.currentHp = Math.max(0, defender.currentHp - dmg);
    defender.damagedThisTurn = true;
    updateHpBar(!isPlayer ? 'player' : 'opponent');
    showDmgFloat(!isPlayer ? 'player' : 'opponent', dmg, isBigHit, false);
    log(`  ${defName} takes ${dmg} ${hitAbility.dmgType} damage!${isCrit ? ' (CRIT)' : ''}`, 'damage');
    renderRoster(!isPlayer ? 'player' : 'opponent');

    // Soul Snatcher: lifesteal on attacks
    if (attacker.stance?.passive === 'attackLifesteal' && dmg > 0 && !hitAbility.heal && attacker.currentHp < attacker.maxHp) {
      const steal = Math.max(1, Math.floor(dmg * 0.10));
      attacker.currentHp = Math.min(attacker.maxHp, attacker.currentHp + steal);
      updateHpBar(isPlayer ? 'player' : 'opponent');
      log(`  Soul Snatcher! ${atkName} drains ${steal} HP!`, 'heal');
    }

    // Shatter unfreezes after dealing bonus damage
    if (hitAbility.requiresFrozen && defender.status === 'frozen') {
      defender.status = null; defender.statusTurns = 0;
      log(`  ${defName} shatters free from the ice!`, 'status');
      updateHpBar(!isPlayer ? 'player' : 'opponent');
    }

    if (hitAbility.drain) {
      const healAmt = Math.floor(dmg * hitAbility.drain);
      attacker.currentHp = Math.min(attacker.maxHp, attacker.currentHp + healAmt);
      updateHpBar(isPlayer ? 'player' : 'opponent');
      log(`  ${atkName} drains ${healAmt} HP!`, 'heal');
      renderRoster(isPlayer ? 'player' : 'opponent');
    }

    // Subdue: lock opponent's switch
    if (hitAbility.lockSwitch) {
      defender.switchLocked = true;
      log(`  ${defName} is pinned! Can't switch next turn.`, 'status');
    }

    // Dirty Boxing stance: chance to stun on dealing damage
    if (attacker.stance && attacker.stance.passive === 'stunOnHit' && !defender.status && !defender.fainted && defender.currentHp > 0) {
      const stunChance = 0.3 + Math.max(0, (attacker.stats.cha - defender.stats.cha)) * 0.02;
      if (Math.random() < stunChance) {
        defender.status = 'stun'; defender.statusTurns = 1;
        log(`  Dirty Boxing! ${defName} is stunned!`, 'status');
        updateHpBar(!isPlayer ? 'player' : 'opponent');
      }
    }

    if (hitAbility.effect && !defender.status) {
      const saveDC = 8 + mod(attacker.stats[hitAbility.stat]) + Math.floor(attacker.level/4) + 2;
      const save = d(20) + mod(defender.stats.def);
      if (save < saveDC) {
        const turns = hitAbility.effect === 'stun' ? 1 : 3;
        defender.status = hitAbility.effect; defender.statusTurns = turns;
        log(`  ${defName} is ${hitAbility.effect}ed! (DC ${saveDC}, saved ${save})`, 'status');
      } else {
        log(`  ${defName} saves vs ${hitAbility.effect}! (DC ${saveDC}, rolled ${save})`, 'roll');
      }
      updateHpBar(!isPlayer ? 'player' : 'opponent');
    }

    // Freeze chance (from ability or Arctic Aura stance)
    if (!defender.status && !defender.fainted && defender.currentHp > 0) {
      let freezeChance = hitAbility.freezeChance || 0;
      if (attacker.stance && attacker.stance.passive === 'freezeAll') freezeChance += 0.1;
      freezeChance += Math.max(0, (attacker.stats.cha - defender.stats.cha)) * 0.02; // CHA additive scaling
      if (freezeChance > 0 && Math.random() < freezeChance) {
        defender.status = 'frozen'; defender.statusTurns = 99;
        log(`  ${defName} is frozen solid!`, 'status');
        updateHpBar(!isPlayer ? 'player' : 'opponent');
      }
    }

    // Blind application from Radial Strike
    if (hitAbility.blindChance && !defender.fainted && defender.currentHp > 0) {
      if (Math.random() < hitAbility.blindChance + Math.max(0, (attacker.stats.cha - defender.stats.cha)) * 0.02) {
        defender.blindStacks++;
        log(`  ${defName} is blinded! (${defender.blindStacks} stack${defender.blindStacks>1?'s':''}, ${defender.blindStacks*15}% miss)`, 'status');
        updateHpBar(!isPlayer ? 'player' : 'opponent');
      }
    }

    // Battlefield Star: small chance to blind each hit
    if (attacker.stance && attacker.stance.passive === 'blindPerTurn' && !defender.fainted && defender.currentHp > 0) {
      const bsBlindChance = 0.25 + Math.max(0, (attacker.stats.cha - defender.stats.cha)) * 0.02;
      if (Math.random() < bsBlindChance) {
        defender.blindStacks++;
        log(`  Battlefield Star! ${defName} is dazzled! (${defender.blindStacks} blind stack${defender.blindStacks>1?'s':''})`, 'status');
        updateHpBar(!isPlayer ? 'player' : 'opponent');
      }
    }

    // Burn chance (Emberang)
    if (hitAbility.burnChance && !defender.fainted && defender.currentHp > 0) {
      const bChance = hitAbility.burnChance + Math.max(0, (attacker.stats.cha - defender.stats.cha)) * 0.02;
      if (Math.random() < bChance) {
        defender.burnStacks++;
        log(`  ${defName} is burning! (${defender.burnStacks} stack${defender.burnStacks>1?'s':''})`, 'status');
        updateHpBar(!isPlayer ? 'player' : 'opponent');
      }
    }

    // Poison chance (Poison Dart)
    if (hitAbility.poisonChance && !defender.fainted && defender.currentHp > 0) {
      const pChance = hitAbility.poisonChance + Math.max(0, (attacker.stats.cha - defender.stats.cha)) * 0.02;
      if (Math.random() < pChance) {
        let stacks = hitAbility.poisonStacks || 1;
        // Rapid Transmission: +1 extra stack
        if (attacker.stance?.passive === 'rapidTransmission') {
          const rtChance = 0.30 + Math.max(0, (attacker.stats.cha - defender.stats.cha)) * 0.02;
          if (Math.random() < rtChance) { stacks += 1; log(`  Rapid Transmission! Extra poison stack!`, 'status'); }
        }
        defender.poisonStacks += stacks;
        log(`  ${defName} is poisoned! +${stacks} stacks (${defender.poisonStacks} total, ${defender.poisonStacks * 2} dmg/turn)`, 'status');
        updateHpBar(!isPlayer ? 'player' : 'opponent');
      }
    }

    // Boomerang: schedule return hit for end of next turn
    if (hitAbility.boomerang && !defender.fainted && defender.currentHp > 0) {
      const bonusMult = (attacker.stance?.passive === 'boomerangBonus') ? 1.3 : 1.0;
      defender.boomerangHits.push({ damage: Math.round(dmg * 1.0 * bonusMult), source: atkName, ability: hitAbility.name });
      log(`  The ${hitAbility.name.toLowerCase()} will swing back next turn!`, 'info');
      updateHpBar(!isPlayer ? 'player' : 'opponent');
    }

    // Flinch: chance to make defender skip their action this turn (only on initial hit)
    if (hitAbility.flinchChance && !defender.fainted && defender.currentHp > 0 && !defender.flinched) {
      const fChance = hitAbility.flinchChance + Math.max(0, (attacker.stats.cha - defender.stats.cha)) * 0.02;
      if (Math.random() < fChance) {
        defender.flinched = true;
        log(`  ${defName} flinches! They lose their action this turn!`, 'status');
      }
    }

    // Eviscerate / Chomp: apply Wounded stack
    if ((hitAbility.eviscerate || hitAbility.chomp) && !defender.fainted && defender.currentHp > 0) {
      defender.woundedStacks++;
      log(`  ${defName} is wounded! (${defender.woundedStacks} stack${defender.woundedStacks>1?'s':''} — bonus soul damage on hit)`, 'status');
      updateHpBar(!isPlayer ? 'player' : 'opponent');
    }

    // Wounded: bonus soul damage after being hit
    if (defender.woundedStacks > 0 && dmg > 0 && !hitAbility.heal && !defender.fainted && defender.currentHp > 0) {
      const woundDmg = defender.woundedStacks * 2;
      defender.currentHp = Math.max(0, defender.currentHp - woundDmg);
      updateHpBar(!isPlayer ? 'player' : 'opponent');
      showDmgFloat(!isPlayer ? 'player' : 'opponent', woundDmg, false, false);
      log(`  Wounds tear open! ${defName} takes ${woundDmg} bonus soul damage! (${defender.woundedStacks} stacks)`, 'damage');
    }

    // Reckless Swing: recoil damage to self (10% of damage dealt)
    if (hitAbility.recklessSwing && dmg > 0) {
      const recoil = Math.max(1, Math.round(dmg * 0.1));
      attacker.currentHp = Math.max(1, attacker.currentHp - recoil);
      updateHpBar(isPlayer ? 'player' : 'opponent');
      showDmgFloat(isPlayer ? 'player' : 'opponent', recoil, false, false);
      log(`  Reckless recoil! ${atkName} takes ${recoil} self-damage!`, 'damage');
    }

    // Shield Bash: chance to stun
    if (hitAbility.shieldBash && hitAbility.stunChance && !defender.status && !defender.fainted && defender.currentHp > 0) {
      const sChance = hitAbility.stunChance + Math.max(0, (attacker.stats.cha - defender.stats.cha)) * 0.02;
      if (Math.random() < sChance) {
        defender.status = 'stun'; defender.statusTurns = 1;
        log(`  Shield Bash! ${defName} is stunned!`, 'status');
        updateHpBar(!isPlayer ? 'player' : 'opponent');
      }
    }

    // Duelist stance: gain ATK on dealing damage (lost on next attack or switch)
    if (attacker.stance?.passive === 'duelist' && dmg > 0 && !hitAbility.heal) {
      attacker.duelistStacks += 5;
      attacker.stats.atk += 5;
      log(`  Duelist! ${atkName} gains +5 ATK (total +${attacker.duelistStacks} stacked)!`, 'status');
    }

    // Petal Storm: chance to apply 1 blind stack on hit
    if (hitAbility.petalStorm && hitAbility.blindChance && dmg > 0 && !defender.fainted && defender.currentHp > 0) {
      const bChance = hitAbility.blindChance + Math.max(0, (attacker.stats.cha - defender.stats.cha)) * 0.02;
      if (Math.random() < bChance) {
        defender.blindStacks += 1;
        log(`  Petals blind ${defName}! (${defender.blindStacks} stack${defender.blindStacks>1?'s':''}, ${defender.blindStacks*15}% miss)`, 'status');
      }
      updateHpBar(!isPlayer ? 'player' : 'opponent');
    }

    // Prickly: attacker takes 1 damage when hitting a Prickly unit
    if (defender.stance?.passive === 'prickly' && dmg > 0 && !hitAbility.heal && !attacker.fainted && attacker.currentHp > 0) {
      attacker.currentHp = Math.max(1, attacker.currentHp - 1);
      log(`  Prickly! ${atkName} takes 1 thorn damage from hitting ${defName}!`, 'damage');
      updateHpBar(isPlayer ? 'player' : 'opponent');
    }

    return dmg;
  }

  // Execute the hit(s)
  if (ability.doubleHit) {
    // Tump Up: first hit normal, second hit deals more damage
    await dealHit(ability, 'First hit');
    if (!defender.fainted) {
      await delay(500);
      if (Math.random() < 0.3) {
        log(`  Second hit misses!`, 'miss');
      } else {
        const secondHitAbility = {...ability, fixed: Math.floor((ability.fixed || 0) * 1.5), doubleHit: false};
        await dealHit(secondHitAbility, 'Second hit');
      }
    }
  } else {
    await dealHit(ability);
  }

  // Duelist: consume ATK stacks after attacking (not heals/buffs)
  if (attacker.duelistStacks > 0 && !ability.heal && !ability.chivalry) {
    attacker.stats.atk -= attacker.duelistStacks;
    log(`  Duelist stacks consumed! ${atkName} loses +${attacker.duelistStacks} ATK.`, 'info');
    attacker.duelistStacks = 0;
  }

  if (defender.currentHp <= 0 && !defender.fainted) {
    defender.fainted = true; animateFaint(defender);
    // (killHeal removed — replaced by attackLifesteal)
    if (false) {
      const healAmt = 0;
      attacker.currentHp = attacker.currentHp;
      updateHpBar(isPlayer ? 'player' : 'opponent');
      showDmgFloat(isPlayer ? 'player' : 'opponent', healAmt, false, true);
      log(`  ${atkName}'s Soul Snatcher heals ${healAmt} HP!`, 'heal');
    }
  }

  // Restore stun debuffs after action
  if (stunDebuffs) {
    for (const [stat, val] of Object.entries(stunDebuffs)) {
      attacker.stats[stat] += val;
    }
    if (!attacker.status) log(`${atkName} recovers from the stun!`, 'status');
  }
}

async function tickStatus(battler) {
  const isPlayer = playerTeam.includes(battler);

  // Pit Veteran regen
  if (battler.stance && battler.stance.passive === 'regenTick' && battler.currentHp < battler.maxHp && !battler.fainted) {
    const regen = Math.max(1, Math.floor(battler.maxHp * 0.05));
    battler.currentHp = Math.min(battler.maxHp, battler.currentHp + regen);
    updateHpBar(isPlayer ? 'player' : 'opponent');
    showDmgFloat(isPlayer ? 'player' : 'opponent', regen, false, true);
    log(`${battler.name} regenerates ${regen} HP!`, 'heal');
    renderRoster(isPlayer ? 'player' : 'opponent');
  }

  // Death Lust decrement
  if (battler.deathLustTurns > 0) {
    battler.deathLustTurns--;
    if (battler.deathLustTurns <= 0) {
      log(`${battler.name}'s Death Lust fades.`, 'status');
    }
  }

  // Clear switch lock at end of turn
  battler.switchLocked = false;
  battler.lookAtMeLocked = false;

  // Clear flinch
  battler.flinched = false;

  // Shield decrement
  if (battler.shieldTurns > 0) {
    battler.shieldTurns--;
    if (battler.shieldTurns <= 0) {
      battler.shieldHp = 0;
      log(`${battler.name}'s shield fades.`, 'info');
    }
    updateHpBar(isPlayer ? 'player' : 'opponent');
  }

  // Curse tick: 35% chance per stack to transform into a random status
  if (battler.curseStacks > 0 && !battler.fainted) {
    // Curse can transform into any status: frozen, stun (non-stacking, only if not already that status)
    // or blind, burn, poison, wound (stacking, adds 1 stack)
    for (let i = 0; i < battler.curseStacks; i++) {
      if (Math.random() < 0.35) {
        const options = [];
        // Non-stacking: only if target doesn't have it
        if (battler.status !== 'frozen') options.push('frozen');
        if (battler.status !== 'stun') options.push('stun');
        // Stacking: always available
        options.push('blind', 'burn', 'poison', 'wound');
        const chosen = options[Math.floor(Math.random() * options.length)];
        battler.curseStacks--;
        if (chosen === 'frozen') { battler.status = 'frozen'; battler.statusTurns = 3; }
        else if (chosen === 'stun') { battler.status = 'stun'; battler.statusTurns = 1; }
        else if (chosen === 'blind') { battler.blindStacks++; }
        else if (chosen === 'burn') { battler.burnStacks++; }
        else if (chosen === 'poison') { battler.poisonStacks++; }
        else if (chosen === 'wound') { battler.woundedStacks++; }
        log(`${battler.name}'s curse manifests as ${chosen.toUpperCase()}${['blind','burn','poison','wound'].includes(chosen) ? ' (+1 stack)' : ''}!`, 'status');
        updateHpBar(isPlayer ? 'player' : 'opponent');
        break; // Only one transformation per turn
      }
    }
  }

  // Forbidden Sermon: apply curse stack to opponent
  if (battler.stance?.passive === 'cursePerTurn' && !battler.fainted) {
    const target = isPlayer ? opponent() : player();
    if (target && !target.fainted && target.currentHp > 0) {
      target.curseStacks += 2;
      log(`Forbidden Sermon! ${target.name} gains 2 curse stacks! (${target.curseStacks})`, 'status');
      updateHpBar(!isPlayer ? 'player' : 'opponent');
    }
  }

  // Swerve: track for consecutive use penalty, then clear
  battler.swerveLastTurn = !!battler.swerveActive;
  battler.swerveActive = false;

  // Burn tick: % max HP per stack, 50% chance to lose a stack
  if (battler.burnStacks > 0 && !battler.fainted) {
    const burnDmg = Math.max(1, Math.floor(battler.maxHp * 0.04 * battler.burnStacks));
    battler.currentHp = Math.max(0, battler.currentHp - burnDmg);
    updateHpBar(isPlayer ? 'player' : 'opponent');
    showDmgFloat(isPlayer ? 'player' : 'opponent', burnDmg, true);
    log(`${battler.name} takes ${burnDmg} burn damage! (${battler.burnStacks} stack${battler.burnStacks>1?'s':''})`, 'status');
    if (Math.random() < 0.5) {
      battler.burnStacks--;
      if (battler.burnStacks <= 0) log(`${battler.name}'s burn goes out!`, 'status');
      else log(`  A burn stack fades. (${battler.burnStacks} left)`, 'status');
    }
    renderRoster(isPlayer ? 'player' : 'opponent');
    if (battler.currentHp <= 0) { battler.fainted = true; animateFaint(battler); }
  }

  // Poison tick: fixed 2 damage per stack, stacks don't fall off
  if (battler.poisonStacks > 0 && !battler.fainted) {
    const poisonDmg = battler.poisonStacks * 2;
    battler.currentHp = Math.max(0, battler.currentHp - poisonDmg);
    updateHpBar(isPlayer ? 'player' : 'opponent');
    showDmgFloat(isPlayer ? 'player' : 'opponent', poisonDmg, false);
    log(`${battler.name} takes ${poisonDmg} poison damage! (${battler.poisonStacks} stack${battler.poisonStacks>1?'s':''})`, 'status');
    renderRoster(isPlayer ? 'player' : 'opponent');
    if (battler.currentHp <= 0) { battler.fainted = true; animateFaint(battler); }
  }

  // Boomerang hits resolve
  if (battler.boomerangHits.length > 0 && !battler.fainted) {
    const hits = battler.boomerangHits.splice(0);
    for (const hit of hits) {
      if (battler.fainted) break;
      battler.currentHp = Math.max(0, battler.currentHp - hit.damage);
      updateHpBar(isPlayer ? 'player' : 'opponent');
      showDmgFloat(isPlayer ? 'player' : 'opponent', hit.damage, true);
      log(`${hit.source}'s ${hit.ability} swings back and hits ${battler.name} for ${hit.damage}!`, 'hit');
      battler.damagedThisTurn = true;
      if (battler.currentHp <= 0) { battler.fainted = true; animateFaint(battler); }
    }
    renderRoster(isPlayer ? 'player' : 'opponent');
  }

  if (!battler.status) return;
  if (battler.status === 'poison') {
    const dmg = Math.max(1, Math.floor(battler.maxHp / 10));
    battler.currentHp = Math.max(0, battler.currentHp - dmg);
    updateHpBar(isPlayer ? 'player' : 'opponent');
    battler.statusTurns--;
    log(`${battler.name} takes ${dmg} poison damage!`, 'status');
    renderRoster(isPlayer ? 'player' : 'opponent');
    if (battler.statusTurns <= 0) { battler.status = null; log(`${battler.name}'s poison wears off.`, 'status'); }
    if (battler.currentHp <= 0) { battler.fainted = true; animateFaint(battler); }
  }
  if (battler.status === 'slow') {
    battler.statusTurns--;
    if (battler.statusTurns <= 0) { battler.status = null; log(`${battler.name} is no longer slowed.`, 'status'); }
  }
  // Frozen doesn't tick down - it's handled at action time and on-damage
}

function animateFaint(b) {
  const isPlayer = playerTeam.includes(b);
  document.getElementById(isPlayer ? 'player-sprite' : 'opp-sprite').classList.add('fainted');
}

function showDeathSelectionModal(team, activeIdx) {
  return new Promise(resolve => {
    const modal = document.getElementById('death-select-modal');
    const box = document.getElementById('death-box');
    box.innerHTML = `<h3>${team[activeIdx].name} has fallen!</h3><p>Choose your next fighter:</p>`;
    team.forEach((b, i) => {
      if (i === activeIdx || b.fainted) return;
      const pct = Math.max(0, b.currentHp / b.maxHp * 100);
      const statusStr = b.status ? ` [${b.status.toUpperCase()}]` : '';
      const btn = document.createElement('button');
      btn.className = 'char-btn';
      btn.innerHTML = `<div class="char-name" style="color:${b.cls.color}">${b.name} the ${b.cls.label}${statusStr}</div>
        <div class="char-info">HP: ${b.currentHp}/${b.maxHp} (${Math.round(pct)}%) | ATK ${b.stats.atk} DEF ${b.stats.def} INT ${b.stats.int} SPD ${b.stats.spd}</div>`;
      btn.onclick = () => { modal.classList.remove('show'); resolve(i); };
      box.appendChild(btn);
    });
    modal.classList.add('show');
  });
}

async function handleFaint(who) {
  const team = who === 'player' ? playerTeam : oppTeam;
  const active = who === 'player' ? playerActive : oppActive;
  const b = team[active];
  if (!b.fainted) return;

  const deathLines = ['collapses!','crumples in defeat!','falls lifeless!','is vanquished!'];
  log(`${b.name} ${pick(deathLines)}`, 'faint');

  // If a summon faints, restore the owner to the slot (unfainted) — then normal death selection picks who comes in
  if (b.isSummon && b.summonOwner) {
    const owner = b.summonOwner;
    team[active] = owner; // Druid returns to roster as alive unit
    log(`${owner.name} returns from the sidelines!`, 'info');
    renderRoster(who);
    // Fall through to normal death selection — Druid is now at team[active] and is alive,
    // so they'll appear in the selection (since we check i !== active only for non-fainted)
  }

  renderRoster(who);

  await delay(1000);

  // Include current slot in alive check if the unit there is alive (e.g. Druid restored after boar death)
  const ownerReturned = !b.fainted || (team[active] && !team[active].fainted && team[active] !== b);
  const alive = team.filter((t, i) => !t.fainted && (i !== active || ownerReturned));
  if (alive.length === 0) return;

  let nextIdx;
  if (who === 'player' && !autoMode) {
    // Player picks their next character (pass -1 as exclude so all alive shown when owner returned)
    nextIdx = await showDeathSelectionModal(team, ownerReturned ? -1 : active);
  } else {
    // AI picks from alive characters
    const aliveIndices = team.map((t, i) => i).filter(i => !team[i].fainted && (i !== active || ownerReturned));
    nextIdx = pick(aliveIndices);
  }

  if (who === 'player') playerActive = nextIdx;
  else oppActive = nextIdx;
  const next = who === 'player' ? player() : opponent();
  next.justSwitchedIn = true;
  log(`${next.name} the ${next.cls.label} enters the fight!`, 'switch');
  renderActiveInfo(who); renderSprite(who); renderRoster(who);

  // Stance selection for new character — always clear and re-prompt
  if (who === 'player' && next.stances) {
    removeStance(next); // clear any old stance
    if (autoMode) { applyStance(next, aiPickStance(next)); }
    else {
      const stance = await showStanceModal(next);
      applyStance(next, stance);
      log(`${next.name} enters ${stance.name} stance! ${stance.desc}`, 'info');
    }
    renderActiveInfo(who); renderRoster(who); renderMoves();
  } else if (who === 'opponent' && next.stances) {
    removeStance(next);
    applyStance(next, aiPickStance(next));
    renderActiveInfo(who); renderRoster(who);
  }

  await delay(1000);
}

function checkWin() {
  const pAlive = playerTeam.some(b => !b.fainted);
  const oAlive = oppTeam.some(b => !b.fainted);
  if (!pAlive) {
    losses++; document.getElementById('p-losses').textContent = losses;
    log('All your warriors have fallen. Defeat!', 'faint');
    setTimeout(() => { startBattle(); if (autoMode) scheduleAutoTurn(); }, autoMode ? 1200 : 2000);
    return true;
  }
  if (!oAlive) {
    wins++; document.getElementById('p-wins').textContent = wins;
    log('All enemies defeated. Victory!', 'win');
    setTimeout(() => { startBattle(); if (autoMode) scheduleAutoTurn(); }, autoMode ? 1200 : 2000);
    return true;
  }
  return false;
}

function showDiceFloat(who, text) {
  const area = who === 'player' ? document.querySelector('.player-area') : document.querySelector('.opponent-area');
  const el = document.createElement('div');
  el.className = 'dmg-float dice-roll';
  el.style.color = '#aa9';
  el.style.fontSize = '11px';
  el.style.top = '5px';
  el.textContent = text;
  el.style.left = (10 + Math.random() * 60) + 'px';
  area.appendChild(el);
  setTimeout(() => el.remove(), 1500);
}

function showDmgFloat(who, amount, isCrit, isHeal) {
  const area = who === 'player' ? document.querySelector('.player-area') : document.querySelector('.opponent-area');
  const el = document.createElement('div');
  el.className = 'dmg-float' + (isCrit ? ' crit' : '') + (isHeal ? ' heal' : '');
  el.style.color = isHeal ? '#6aaa5a' : '#cc6644';
  el.textContent = (isHeal ? '+' : '-') + amount + (isCrit ? ' CRIT!' : '');
  el.style.left = (30 + Math.random() * 40) + 'px';
  el.style.top = '20px';
  area.appendChild(el);
  setTimeout(() => el.remove(), 1500);
  // Red flash + screen shake on crit
  if (isCrit && !isHeal) {
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(200,30,30,0.25);pointer-events:none;z-index:9999;transition:opacity 0.4s;';
    document.body.appendChild(overlay);
    setTimeout(() => { overlay.style.opacity = '0'; }, 50);
    setTimeout(() => overlay.remove(), 500);
    // Screen shake
    document.body.style.transition = 'none';
    const frames = [
      { x: -4, y: 3 }, { x: 5, y: -2 }, { x: -3, y: -4 },
      { x: 4, y: 2 }, { x: -2, y: 3 }, { x: 0, y: 0 }
    ];
    let i = 0;
    const shakeInterval = setInterval(() => {
      if (i >= frames.length) { clearInterval(shakeInterval); document.body.style.transform = ''; return; }
      document.body.style.transform = `translate(${frames[i].x}px, ${frames[i].y}px)`;
      i++;
    }, 40);
  }
}

// ============================================================
//  AI
// ============================================================
// AI switch decision: evaluates whether to swap out based on matchup + HP
function aiShouldSwitch() {
  const o = opponent();
  const p = player();
  // Can't switch if locked, pinned, or no bench
  if (o.switchLocked || o.lookAtMeLocked) return null;
  const bench = oppTeam.filter((m, i) => i !== oppActive && !m.fainted);
  if (bench.length === 0) return null;
  // Don't switch summons
  if (o.isSummon) return null;

  // Matchup scoring: how well does current unit do vs player's current unit?
  function matchupScore(me, them) {
    let s = 0;
    // Physical attackers like low DEF targets
    if (me.cls.statWeights.atk >= 3 && them.stats.def < 10) s += 15;
    // Magic attackers like low INT targets
    if (me.cls.statWeights.int >= 3 && them.stats.int < 10) s += 15;
    // HP advantage
    s += (me.currentHp / me.maxHp - them.currentHp / them.maxHp) * 20;
    // Class-specific advantages
    if (me.cls.name === 'Paladin' && them.cls.name === 'Rogue') s += 15;
    if (me.cls.name === 'Mage' && them.cls.name === 'Paladin') s += 15;
    if (me.cls.name === 'Warrior' && them.cls.name === 'Rogue') s += 15;
    if (me.cls.name === 'Ranger' && them.cls.name === 'Paladin') s += 10;
    if (me.cls.name === 'Ranger' && them.cls.name === 'Berserker') s += 10;
    if (me.cls.name === 'Rogue' && them.cls.name === 'Berserker') s += 10;
    if (me.cls.name === 'Rogue' && them.cls.name === 'Cleric') s += 20;
    if (me.cls.name === 'Druid' && them.cls.name === 'Paladin') s += 10;
    // Support classes prefer staying back
    if (me.cls.name === 'Cleric') s -= 10;
    return s;
  }

  const currentScore = matchupScore(o, p);
  let bestBench = null, bestScore = currentScore;
  for (const b of bench) {
    const sc = matchupScore(b, p) + (b.currentHp / b.maxHp) * 10;
    if (sc > bestScore) { bestScore = sc; bestBench = b; }
  }

  // Switch if critically low HP and a better option exists
  if (o.currentHp < o.maxHp * 0.25 && bestBench && bestScore > currentScore + 10) {
    return oppTeam.indexOf(bestBench);
  }
  // Switch if significantly better matchup available
  if (bestBench && bestScore > currentScore + 25) {
    return oppTeam.indexOf(bestBench);
  }
  return null;
}

function pickAIAbility() {
  const o = opponent();
  if (o.currentHp < o.maxHp * 0.3) {
    const healIdx = o.abilities.findIndex(a => a.heal && a.currentUses > 0);
    if (healIdx >= 0) return healIdx;
  }
  // Remedial Ointment: use when poisoned and below 70% HP, or 4+ stacks at any HP
  if ((o.poisonStacks >= 2 && o.currentHp < o.maxHp * 0.7) || o.poisonStacks >= 4) {
    const ointIdx = o.abilities.findIndex(a => a.remedialOintment && a.currentUses > 0);
    if (ointIdx >= 0) return ointIdx;
  }
  let best = -1, bestScore = -Infinity;
  o.abilities.forEach((ab, i) => {
    if (ab.currentUses <= 0 || ab.heal) return;
    if (ab.requiresFrozen && player().status !== 'frozen') return;
    if (ab.grantWhittle && o.whittleBoost >= 8) return;
    if (o.bladeTossCooldown && (ab.bladeToss || ab.recklessSwing)) return;
    let score;
    if (ab.chivalry) { score = 8 * (0.8 + Math.random() * 0.4); } // Low priority unless predicting switch
    else if (ab.shieldBash) { score = 12 * (0.8 + Math.random() * 0.4); }
    else if (ab.swerve) { score = (o.swerveLastTurn ? 5 : 20) * (0.8 + Math.random() * 0.4); }
    else if (ab.grantWhittle) { score = (o.whittleBoost === 0 ? 25 : 15) * (0.8 + Math.random() * 0.4); }
    else if (ab.goblinGas) { score = (!terrain ? 30 : 3) * (0.8 + Math.random() * 0.4); } // High priority opener
    else if (ab.violentExtraction) { score = (player().poisonStacks >= 3 ? player().poisonStacks * 10 : 1) * (0.8 + Math.random() * 0.4); } // Cash out at 3+ stacks
    else if (ab.remedialOintment) { score = (o.poisonStacks >= 2 ? o.poisonStacks * 6 : 0) * (0.8 + Math.random() * 0.4); } // Proactive sustain
    else if (ab.ancientPower) { score = 22 * (0.8 + Math.random() * 0.4); } // High delayed damage
    else if (ab.transference) { score = ((o.poisonStacks + o.burnStacks + o.blindStacks + o.woundedStacks) * 6 + (o.status ? 15 : 0)) * (0.8 + Math.random() * 0.4); }
    else if (ab.summonBoar) { score = (o.currentHp < o.maxHp * 0.4 ? 30 : 10) * (0.8 + Math.random() * 0.4); } // Summon when low HP to preserve Druid
    else if (ab.chomp) { score = 10 * (0.8 + Math.random() * 0.4); }
    else if (ab.moonlight) { const hurt = oppTeam.filter(m => !m.fainted && m.currentHp < m.maxHp * 0.8).length; score = (hurt > 0 ? hurt * 12 : 3) * (0.8 + Math.random() * 0.4); }
    else if (ab.readScripture) { score = 12 * (0.8 + Math.random() * 0.4); }
    else if (ab.riot) { score = 18 * (0.8 + Math.random() * 0.4); }
    else if (ab.lookAtMe) { score = 10 * (0.8 + Math.random() * 0.4); }
    else {
      const avgDmg = (ab.fixed || 0) + ab.dice[0] * (ab.dice[1] + 1) / 2;
      score = avgDmg * (0.8 + Math.random() * 0.4);
      if (ab.requiresFrozen && player().status === 'frozen') { score += (ab.currentHpPct || 0) * player().currentHp; score *= 2; }
      if (ab.boomerang) score *= 1.3;
    }
    if (score > bestScore) { bestScore = score; best = i; }
  });
  if (best === -1) best = o.abilities.findIndex(a => a.currentUses > 0) || 0;
  return best;
}

function pickSmartMove() {
  const p = player();
  if (p.currentHp < p.maxHp * 0.3) {
    const healIdx = p.abilities.findIndex(a => a.heal && a.currentUses > 0);
    if (healIdx >= 0) return healIdx;
  }
  let best = -1, bestScore = -Infinity;
  p.abilities.forEach((ab, i) => {
    if (ab.currentUses <= 0 || ab.heal) return;
    if (ab.requiresFrozen && opponent().status !== 'frozen') return;
    if (ab.grantWhittle && p.whittleBoost >= 8) return;
    if (p.bladeTossCooldown && (ab.bladeToss || ab.recklessSwing)) return;
    let score;
    if (ab.chivalry) { score = 8 * (0.85 + Math.random() * 0.3); }
    else if (ab.shieldBash) { score = 12 * (0.85 + Math.random() * 0.3); }
    else if (ab.swerve) { score = (p.swerveLastTurn ? 5 : 20) * (0.85 + Math.random() * 0.3); }
    else if (ab.grantWhittle) { score = (p.whittleBoost === 0 ? 25 : 15) * (0.85 + Math.random() * 0.3); }
    else if (ab.goblinGas) { score = (!terrain ? 25 : 3) * (0.85 + Math.random() * 0.3); }
    else if (ab.violentExtraction) { score = (opponent().poisonStacks >= 3 ? opponent().poisonStacks * 10 : 1) * (0.85 + Math.random() * 0.3); }
    else if (ab.remedialOintment) { score = (p.poisonStacks >= 2 ? p.poisonStacks * 6 : 0) * (0.85 + Math.random() * 0.3); }
    else if (ab.ancientPower) { score = 22 * (0.85 + Math.random() * 0.3); }
    else if (ab.transference) { score = ((p.poisonStacks + p.burnStacks + p.blindStacks + p.woundedStacks) * 6 + (p.status ? 15 : 0)) * (0.85 + Math.random() * 0.3); }
    else if (ab.summonBoar) { score = (p.currentHp < p.maxHp * 0.4 ? 30 : 10) * (0.85 + Math.random() * 0.3); }
    else if (ab.moonlight) { const hurt = playerTeam.filter(m => !m.fainted && m.currentHp < m.maxHp * 0.8).length; score = (hurt > 0 ? hurt * 12 : 3) * (0.85 + Math.random() * 0.3); }
    else if (ab.readScripture) { score = 12 * (0.85 + Math.random() * 0.3); }
    else if (ab.riot) { score = 18 * (0.85 + Math.random() * 0.3); }
    else if (ab.lookAtMe) { score = 10 * (0.85 + Math.random() * 0.3); }
    else if (ab.chomp) { score = 10 * (0.85 + Math.random() * 0.3); }
    else {
      const avgDmg = (ab.fixed || 0) + ab.dice[0] * (ab.dice[1] + 1) / 2;
      score = avgDmg * (0.85 + Math.random() * 0.3);
      if (ab.requiresFrozen && opponent().status === 'frozen') { score += (ab.currentHpPct || 0) * opponent().currentHp; score *= 2; }
      if (ab.boomerang) score *= 1.3;
    }
    if (score > bestScore) { bestScore = score; best = i; }
  });
  if (best === -1) best = p.abilities.findIndex(a => a.currentUses > 0) || 0;
  return best;
}

// ============================================================
//  AUTO BATTLE
// ============================================================
let autoSpeed = 500;
const btnAuto = document.getElementById('btn-auto');
btnAuto.onclick = () => {
  autoMode = !autoMode;
  btnAuto.classList.toggle('active', autoMode);
  btnAuto.textContent = autoMode ? 'Stop Auto' : 'Auto Battle';
  if (autoMode && !isAnimating) scheduleAutoTurn();
  if (!autoMode && autoTimer) { clearTimeout(autoTimer); autoTimer = null; }
};
const speedSlider = document.getElementById('speed-slider');
const speedLabel = document.getElementById('speed-label');
speedSlider.oninput = () => { autoSpeed = parseInt(speedSlider.value); speedLabel.textContent = autoSpeed + 'ms'; };

function scheduleAutoTurn() {
  if (!autoMode) return;
  autoTimer = setTimeout(() => {
    if (!autoMode || isAnimating) return;
    executeTurn(pickSmartMove());
  }, autoSpeed);
}

// ============================================================
//  INIT
// ============================================================
startBattle();
</script>
</body>
</html>
